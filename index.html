<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VoiceBot Flow Editor - Ultimate</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #0b1220 0%, #1e293b 100%);
      --panel: rgba(15, 23, 42, 0.95);
      --muted: #94a3b8;
      --text: #e2e8f0;
      --accent: #22d3ee;
      --danger: #ef4444;
      --ok: #10b981;
      --warning: #f59e0b;
      --card: rgba(17, 24, 39, 0.8);
      --border: #1f2937;
      --shadow: 0 8px 32px rgba(0,0,0,.4);
      --glow: 0 0 20px rgba(34, 211, 238, 0.3);
      --connection-color: #ffff00;
    }

    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      overflow: hidden;
    }

    html[dir="rtl"] {
      direction: rtl;
    }

    .app {
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr auto;
      height: 100vh;
      position: relative;
    }

    html[dir="rtl"] .app {
      grid-template-columns: 1fr 320px;
    }

    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 200px 1fr auto;
      }
      
      html[dir="rtl"] .app {
        grid-template-columns: 1fr;
      }
      
      .sidebar {
        max-height: 200px;
        overflow-y: auto;
      }
      
      .zoom-controls {
        bottom: 10px !important;
        right: 10px !important;
        transform: scale(0.8);
      }
      
      html[dir="rtl"] .zoom-controls {
        right: auto !important;
        left: 10px !important;
      }
    }

    header {
      grid-column: 1/3;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: linear-gradient(90deg, rgba(11, 18, 32, 0.95), rgba(15, 23, 42, 0.95));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 768px) {
      header {
        padding: 8px 15px;
        font-size: 14px;
      }
    }

    .title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 18px;
    }

    @media (max-width: 768px) {
      .title {
        font-size: 16px;
        gap: 8px;
      }
    }

    .title input {
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 8px 14px;
      border-radius: 12px;
      color: var(--text);
      font-size: 14px;
      transition: all 0.15s ease;
      backdrop-filter: blur(5px);
      position: relative;
    }

    @media (max-width: 768px) {
      .title input {
        font-size: 12px;
        padding: 6px 10px;
      }
    }

    .title input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .sidebar {
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(15px);
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
    }

    html[dir="rtl"] .sidebar {
      border-right: none;
      border-left: 1px solid var(--border);
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 3px;
    }

    .sidebar h3 {
      margin: 20px 16px 12px;
      font-size: 13px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    @media (max-width: 768px) {
      .sidebar h3 {
        margin: 10px 12px 8px;
        font-size: 12px;
      }
    }

    .group {
      padding: 0 12px 20px;
    }

    @media (max-width: 768px) {
      .group {
        padding: 0 8px 15px;
      }
    }

    .btn {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(51, 65, 85, 0.6));
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size: 13px;
      font-weight: 500;
      position: relative;
      overflow: hidden;
      display: block;
      width: 100%;
      margin-bottom: 8px;
      text-align: left;
    }

    @media (max-width: 768px) {
      .btn {
        padding: 8px 10px;
        font-size: 12px;
        margin-bottom: 6px;
      }
    }

    html[dir="rtl"] .btn {
      text-align: right;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0,0,0,.5);
      border-color: var(--accent);
    }

    .btn:active {
      transform: translateY(0);
    }

    .node-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-start;
    }

    html[dir="rtl"] .node-btn {
      justify-content: flex-end;
    }

    .badge {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      box-shadow: 0 0 8px currentColor;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .green { background: #16a34a; }
    .blue { background: #3b82f6; }
    .amber { background: #f59e0b; }
    .rose { background: #f43f5e; }
    .teal { background: #14b8a6; }
    .violet { background: #8b5cf6; }
    .slate { background: #64748b; }

    .toolbar {
      grid-column: 1/3;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 12px 20px;
      background: rgba(14, 21, 38, 0.9);
      border-top: 1px solid var(--border);
      backdrop-filter: blur(10px);
      align-items: center;
    }

    @media (max-width: 768px) {
      .toolbar {
        padding: 8px 15px;
        gap: 6px;
      }
    }

    main {
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .note {
      color: var(--muted);
      font-size: 11px;
      margin: 12px 16px;
      line-height: 1.4;
      background: rgba(30, 41, 59, 0.3);
      padding: 10px;
      border-radius: 8px;
      border-left: 3px solid var(--accent);
    }

    @media (max-width: 768px) {
      .note {
        font-size: 10px;
        margin: 8px 12px;
        padding: 8px;
      }
    }

    html[dir="rtl"] .note {
      border-left: none;
      border-right: 3px solid var(--accent);
    }

    .pill {
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 11px;
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(5px);
    }

    @media (max-width: 768px) {
      .pill {
        padding: 4px 8px;
        font-size: 10px;
      }
    }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, #111827, #1f2937);
      border: 1px solid var(--border);
      padding: 12px 18px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      display: none;
      font-size: 14px;
      z-index: 1000;
      animation: slideIn 0.2s ease;
    }

    html[dir="rtl"] .toast {
      right: auto;
      left: 20px;
    }

    @media (max-width: 768px) {
      .toast {
        bottom: 10px;
        right: 10px;
        padding: 8px 12px;
        font-size: 12px;
      }
      
      html[dir="rtl"] .toast {
        right: auto;
        left: 10px;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .stats-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .stats-panel {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
        margin-bottom: 12px;
      }
    }

    .stat-card {
      background: var(--card);
      padding: 12px 8px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid var(--border);
    }

    @media (max-width: 768px) {
      .stat-card {
        padding: 8px 6px;
      }
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: var(--accent);
    }

    @media (max-width: 768px) {
      .stat-value {
        font-size: 16px;
      }
    }

    .stat-label {
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      margin-top: 4px;
    }

    @media (max-width: 768px) {
      .stat-label {
        font-size: 9px;
      }
    }

    .search-box {
      width: 100%;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: 12px;
      color: var(--text);
      font-size: 13px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .search-box {
        padding: 8px 10px;
        font-size: 12px;
        margin-bottom: 12px;
      }
    }

    .search-box:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .notes-textarea {
      width: 100%;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 10px;
      border-radius: 12px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 16px;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    .notes-textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .validation-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .validation-panel {
        padding: 8px;
        margin-bottom: 12px;
      }
    }

    .validation-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      .validation-item {
        font-size: 10px;
        gap: 6px;
        padding: 4px 0;
      }
    }

    .validation-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .validation-icon {
        width: 14px;
        height: 14px;
        font-size: 9px;
      }
    }

    .validation-error { background: var(--danger); }
    .validation-warning { background: var(--warning); }
    .validation-success { background: var(--ok); }

    .context-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      box-shadow: var(--shadow);
      backdrop-filter: blur(15px);
      z-index: 1000;
      min-width: 150px;
    }

    .context-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text);
      transition: background 0.15s;
    }

    .context-menu-item:hover {
      background: rgba(34, 211, 238, 0.1);
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background-image: radial-gradient(circle, #1f2937 1px, transparent 1px);
      background-size: 20px 20px;
      cursor: grab;
      user-select: none;
    }

    #canvas-container.panning {
      cursor: grabbing;
    }

    .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      transition: transform 0.05s ease-out;
    }

    .flow-node {
      position: absolute;
      user-select: none;
      pointer-events: all;
      padding: 12px 16px;
      min-width: 150px;
      text-align: center;
      font-weight: 600;
      font-size: 13px;
      color: white;
      border: 2px solid;
      cursor: move;
      border-radius: 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
      transition: all 0.05s ease;
    }

    @media (max-width: 768px) {
      .flow-node {
        padding: 8px 12px;
        min-width: 120px;
        font-size: 11px;
      }
    }

    .flow-node:hover {
      transform: scale(1.02);
      box-shadow: 0 12px 40px rgba(0,0,0,.6);
    }

    .flow-node.selected {
      border-width: 3px;
      box-shadow: 0 0 20px var(--accent);
    }

    .flow-node.dragging {
      z-index: 1000;
      transform: scale(1.05);
    }

    .connection-line {
      position: absolute;
      pointer-events: none;
      z-index: 1;
    }

    .connection-point {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--accent);
      border-radius: 50%;
      cursor: crosshair;
      border: 2px solid white;
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .connection-point {
        width: 10px;
        height: 10px;
        right: -6px;
      }
    }

    html[dir="rtl"] .connection-point {
      right: auto;
      left: -8px;
    }

    @media (max-width: 768px) {
      html[dir="rtl"] .connection-point {
        left: -6px;
      }
    }

    .connection-point:hover {
      transform: translateY(-50%) scale(1.3);
      box-shadow: 0 0 10px var(--accent);
    }

    .input-connection-point {
      right: auto;
      left: -8px;
    }

    @media (max-width: 768px) {
      .input-connection-point {
        left: -6px;
      }
    }

    html[dir="rtl"] .input-connection-point {
      left: auto;
      right: -8px;
    }

    @media (max-width: 768px) {
      html[dir="rtl"] .input-connection-point {
        right: -6px;
      }
    }

    .file-input {
      display: none;
    }

    .search-highlight {
      animation: searchPulse 0.5s ease-in-out infinite alternate;
    }
    
    @keyframes searchPulse {
      from {
        box-shadow: 0 0 10px var(--accent);
        transform: scale(1);
      }
      to {
        box-shadow: 0 0 20px var(--accent);
        transform: scale(1.02);
      }
    }

    .selection-box {
      position: absolute;
      border: 2px dashed var(--accent);
      background: rgba(34, 211, 238, 0.1);
      pointer-events: none;
      z-index: 100;
    }

    .zoom-controls {
      position: absolute;
      bottom: 4cm;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }

    html[dir="rtl"] .zoom-controls {
      right: auto;
      left: 20px;
    }

    .zoom-btn {
      width: 40px;
      height: 40px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .zoom-btn {
        width: 35px;
        height: 35px;
        font-size: 16px;
      }
    }

    .zoom-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .zoom-indicator {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      text-align: center;
      min-width: 60px;
    }

    @media (max-width: 768px) {
      .zoom-indicator {
        padding: 6px 8px;
        font-size: 10px;
        min-width: 50px;
      }
    }

    .connection-color-picker {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      justify-content: center;
    }

    .color-option {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }

    .color-option.active {
      border-color: white;
      transform: scale(1.2);
    }

    .color-yellow { background: #ffff00; }
    .color-blue { background: #00bfff; }
    .color-red { background: #ff4444; }

    .tooltip {
      position: relative;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .tooltip:hover::after {
      opacity: 1;
    }

    .language-toggle {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      display: flex;
      gap: 4px;
    }

    .lang-btn {
      padding: 6px 12px;
      background: none;
      border: none;
      color: var(--muted);
      font-size: 12px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .lang-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
    }

    .lang-btn.active {
      background: var(--accent);
      color: white;
    }

    .autosave-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    @media (max-width: 768px) {
      .autosave-indicator {
        font-size: 10px;
        gap: 6px;
      }
    }

    .autosave-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--ok);
      animation: pulse 1s infinite;
    }

    .autosave-dot.saving {
      background: var(--warning);
      animation: pulse 0.3s infinite;
    }

    .layout-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    @media (max-width: 768px) {
      .layout-options {
        gap: 6px;
      }
    }

    .layout-btn {
      padding: 8px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      text-align: center;
      font-size: 11px;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .layout-btn {
        padding: 6px;
        font-size: 10px;
      }
    }

    .layout-btn:hover {
      border-color: var(--accent);
      background: rgba(34, 211, 238, 0.1);
    }

    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-top: 1px solid var(--border);
      padding: 8px 20px;
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      z-index: 1000;
    }

    @media (max-width: 768px) {
      .footer {
        padding: 6px 15px;
        font-size: 10px;
      }
    }
@keyframes dash {
  to {
    stroke-dashoffset: -10;
  }
}

#temp-connection-path {
  stroke-dasharray: 5, 5;
  animation: dash 0.5s linear infinite;
}
  </style>
</head>
<body>
  <div id="root"></div>
  <div class="toast" id="toast">Action completed</div>
  
  <div class="footer">
    Created for Consist by Moti Kalimi | יוצר לטובת קונסיסט ע"י מוטי קלימי
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const root = document.getElementById('root');
      const toast = document.getElementById('toast');
      
      // Global state
      let nodes = [];
      let connections = [];
      let selectedNodes = [];
      let dragState = null;
      let nodeIdCounter = 1;
      let isConnecting = false;
      let connectionStart = null;
      let currentLanguage = 'en';
      let lastSaved = new Date();
      let hasUnsavedChanges = false;
      let connectionColor = '#ffff00';
      let flowNotes = '';
      
      // Temporary connection line for dragging
      let tempConnectionLine = null;
      let isDraggingConnection = false;

      // Variables to throttle temporary line updates for smoother mouse tracking
      let tempLineAnimationFrame = null;
      let tempLineCoords = { x: 0, y: 0 };
      
      // Canvas state
      let canvasScale = 1;
      let canvasX = 0;
      let canvasY = 0;
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      
      // Selection box state
      let isSelecting = false;
      let selectionStart = { x: 0, y: 0 };
      let selectionBox = null;

      // Translations
      const translations = {
        en: {
          title: "VoiceBot Flow Editor Ultimate",
          flowName: "Enter flow name...",
          nodeTypes: "Node Types",
          layoutTools: "Layout & Tools",
          fileOps: "File Operations",
          autoLayout: "Auto Layout",
          clearAll: "Clear All",
          saveFlow: "Save Flow",
          loadFlow: "Load Flow",
          exportJson: "Export JSON",
          importJson: "Import JSON",
          search: "Search nodes...",
          validation: "Flow Validation",
          controls: "Controls",
          controlsText: "• Drag to connect nodes\n• Double-click to rename\n• Right-click for menu\n• Shift+drag multi-select\n• Ctrl+click multi-select\n• Mouse wheel to zoom\n• Middle click to pan",
          nodes: "Nodes",
          connections: "Connections",
          start: "Start",
          end: "End",
          ready: "Ready",
          saved: "Saved",
          saving: "Saving...",
          connectionColors: "Connection Colors",
          flowNotes: "Flow Notes",
          notesPlaceholder: "Write your notes here..."
        },
        he: {
          title: "עורך זרימות VoiceBot מתקדם",
          flowName: "הזן שם זרימה...",
          nodeTypes: "סוגי צמתים",
          layoutTools: "פריסה וכלים",
          fileOps: "פעולות קובץ",
          autoLayout: "פריסה אוטומטית",
          clearAll: "נקה הכל",
          saveFlow: "שמור זרימה",
          loadFlow: "טען זרימה",
          exportJson: "ייצא JSON",
          importJson: "ייבא JSON",
search: "חיפוש צמתים...",
          validation: "בדיקת זרימה",
          controls: "בקרות",
          controlsText: "• גרור כדי לחבר צמתים\n• לחיצה כפולה לשינוי שם\n• לחיצה ימנית לתפריט\n• Shift+גרירה לבחירה מרובה\n• Ctrl+לחיצה לבחירה מרובה\n• גלגלת עכבר לזום\n• לחיצה אמצעית לניווט",
          nodes: "צמתים",
          connections: "חיבורים",
          start: "התחלה",
          end: "סיום",
          ready: "מוכן",
          saved: "נשמר",
          saving: "שומר...",
          connectionColors: "צבעי חיבורים",
          flowNotes: "הערות זרימה",
          notesPlaceholder: "כתוב את ההערות שלך כאן..."
        }
      };

      // Node types with Hebrew translations
      const nodeTypes = [
        { name: { en: 'Start Call', he: 'התחלת שיחה' }, color: '#16a34a', category: 'trigger', badge: 'green' },
        { name: { en: 'Play Audio', he: 'השמעת אודיו' }, color: '#2563eb', category: 'action', badge: 'blue' },
        { name: { en: 'Collect Input', he: 'איסוף קלט' }, color: '#0d9488', category: 'input', badge: 'teal' },
        { name: { en: 'Menu Choice', he: 'בחירת תפריט' }, color: '#7c3aed', category: 'logic', badge: 'violet' },
        { name: { en: 'Decision', he: 'החלטה' }, color: '#d97706', category: 'logic', badge: 'amber' },
        { name: { en: 'Switch', he: 'מתג' }, color: '#6b7280', category: 'logic', badge: 'slate' },
        { name: { en: 'API Call', he: 'קריאת API' }, color: '#e11d48', category: 'action', badge: 'rose' },
        { name: { en: 'Set Variable', he: 'הגדרת משתנה' }, color: '#0d9488', category: 'data', badge: 'teal' },
        { name: { en: 'Wait', he: 'המתנה' }, color: '#6b7280', category: 'flow', badge: 'slate' },
        { name: { en: 'Transfer', he: 'העברה' }, color: '#2563eb', category: 'action', badge: 'blue' },
        { name: { en: 'End Call', he: 'סיום שיחה' }, color: '#dc2626', category: 'end', badge: 'rose' }
      ];

      // Utility functions
      function t(key) {
        return translations[currentLanguage][key] || key;
      }

      function showToast(message, type = 'info') {
        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 3000);
      }

      function generateId() {
        return 'node_' + (nodeIdCounter++);
      }

      function markUnsavedChanges() {
        hasUnsavedChanges = true;
        updateAutosaveIndicator();
      }

      function markSaved() {
        hasUnsavedChanges = false;
        lastSaved = new Date();
        updateAutosaveIndicator();
      }

      function updateAutosaveIndicator() {
        const indicator = document.getElementById('autosave-indicator');
        const dot = indicator?.querySelector('.autosave-dot');
        const text = indicator?.querySelector('.autosave-text');
        
        if (indicator && dot && text) {
          if (hasUnsavedChanges) {
            dot.className = 'autosave-dot saving';
            text.textContent = t('saving');
          } else {
            dot.className = 'autosave-dot';
            // Format time in 24-hour format
            const hours = lastSaved.getHours().toString().padStart(2, '0');
            const minutes = lastSaved.getMinutes().toString().padStart(2, '0');
            const seconds = lastSaved.getSeconds().toString().padStart(2, '0');
            text.textContent = `${t('saved')} ${hours}:${minutes}:${seconds}`;
          }
        }
      }

      function updateStats() {
        const statCards = document.querySelectorAll('.stat-value');
        if (statCards.length >= 4) {
          statCards[0].textContent = nodes.length;
          statCards[1].textContent = connections.length;
          statCards[2].textContent = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת')).length;
          statCards[3].textContent = nodes.filter(n => n.type.includes('End') || n.type.includes('סיום')).length;
        }
      }

      function validateFlow() {
        const validationContainer = document.getElementById('validation-results');
        if (!validationContainer) return;

        const results = [];
        
        // Check for start nodes
        const startNodes = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת'));
        if (startNodes.length === 0) {
          results.push({ type: 'error', message: 'No start node found' });
        } else if (startNodes.length > 1) {
          results.push({ type: 'warning', message: 'Multiple start nodes detected' });
        }

        // Check for end nodes
        const endNodes = nodes.filter(n => n.type.includes('End') || n.type.includes('סיום'));
        if (endNodes.length === 0) {
          results.push({ type: 'warning', message: 'No end node found' });
        }

        // Check for orphaned nodes
        const connectedNodeIds = new Set();
        connections.forEach(conn => {
          connectedNodeIds.add(conn.from);
          connectedNodeIds.add(conn.to);
        });
        
        const orphanedNodes = nodes.filter(node => 
          !connectedNodeIds.has(node.id) && !node.type.includes('Start') && !node.type.includes('התחלת')
        );
        
        if (orphanedNodes.length > 0) {
          results.push({
            type: 'warning',
            message: `${orphanedNodes.length} orphaned node(s) detected`
          });
        }

        // Check flow connectivity from start to end
        if (startNodes.length > 0 && endNodes.length > 0) {
          const reachableFromStart = new Set();
          
          function traverse(nodeId) {
            if (reachableFromStart.has(nodeId)) return;
            reachableFromStart.add(nodeId);
            
            connections
              .filter(c => c.from === nodeId)
              .forEach(c => traverse(c.to));
          }
          
          startNodes.forEach(node => traverse(node.id));
          
          const unreachableEndNodes = endNodes.filter(node => !reachableFromStart.has(node.id));
          if (unreachableEndNodes.length > 0) {
            results.push({
              type: 'error',
              message: `${unreachableEndNodes.length} end node(s) not reachable from start`
            });
          }
        }

        // All good
        if (results.length === 0) {
          results.push({ type: 'success', message: 'Flow validation passed' });
        }

        // Update validation display
        validationContainer.innerHTML = results.map(result => 
          `<div class="validation-item">
            <span class="validation-icon validation-${result.type}">
              ${result.type === 'error' ? '!' : result.type === 'warning' ? '⚠' : '✓'}
            </span>
            <span>${result.message}</span>
          </div>`
        ).join('');
      }

      // Canvas zoom and pan functions
      function updateCanvasTransform() {
        const viewport = document.getElementById('canvas-viewport');
        if (viewport) {
          viewport.style.transform = `translate(${canvasX}px, ${canvasY}px) scale(${canvasScale})`;
        }
        
        const zoomIndicator = document.querySelector('.zoom-indicator');
        if (zoomIndicator) {
          zoomIndicator.textContent = Math.round(canvasScale * 100) + '%';
        }
        
        const zoomDisplay = document.getElementById('zoom-display');
        if (zoomDisplay) {
          zoomDisplay.textContent = Math.round(canvasScale * 100) + '%';
        }
      }

      function zoomIn() {
        canvasScale = Math.min(canvasScale * 1.2, 3);
        updateCanvasTransform();
      }

      function zoomOut() {
        canvasScale = Math.max(canvasScale / 1.2, 0.1);
        updateCanvasTransform();
      }

      function resetZoom() {
        canvasScale = 1;
        canvasX = 0;
        canvasY = 0;
        updateCanvasTransform();
      }

      // Selection box functions
      function createSelectionBox(startX, startY) {
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = startX + 'px';
        selectionBox.style.top = startY + 'px';
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        document.getElementById('canvas-viewport').appendChild(selectionBox);
      }

      function updateSelectionBox(currentX, currentY) {
        if (!selectionBox) return;
        
        const left = Math.min(selectionStart.x, currentX);
        const top = Math.min(selectionStart.y, currentY);
        const width = Math.abs(currentX - selectionStart.x);
        const height = Math.abs(currentY - selectionStart.y);
        
        selectionBox.style.left = left + 'px';
        selectionBox.style.top = top + 'px';
        selectionBox.style.width = width + 'px';
        selectionBox.style.height = height + 'px';
        
        // Select nodes within the box
        const boxRect = {
          left: left,
          top: top,
          right: left + width,
          bottom: top + height
        };
        
        nodes.forEach(node => {
          const nodeRect = {
            left: node.x,
            top: node.y,
            right: node.x + 150,
            bottom: node.y + 50
          };
          
          const isInSelection = 
            nodeRect.left < boxRect.right &&
            nodeRect.right > boxRect.left &&
            nodeRect.top < boxRect.bottom &&
            nodeRect.bottom > boxRect.top;
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            if (isInSelection) {
              if (!selectedNodes.includes(node)) {
                selectedNodes.push(node);
                nodeEl.classList.add('selected');
              }
            } else {
              const index = selectedNodes.indexOf(node);
              if (index > -1) {
                selectedNodes.splice(index, 1);
                nodeEl.classList.remove('selected');
              }
            }
          }
        });
      }

      function removeSelectionBox() {
        if (selectionBox) {
          selectionBox.remove();
          selectionBox = null;
        }
      }

      // Create temporary connection line while dragging
function createTempConnectionLine(startX, startY) {
  removeTempConnectionLine();
  
  const viewport = document.getElementById('canvas-viewport');
  
  tempConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  tempConnectionLine.style.position = 'absolute';
  tempConnectionLine.style.top = '0';
  tempConnectionLine.style.left = '0';
  tempConnectionLine.style.width = '10000px';
  tempConnectionLine.style.height = '10000px';
  tempConnectionLine.style.pointerEvents = 'none';
  tempConnectionLine.style.zIndex = '1000';
  tempConnectionLine.style.overflow = 'visible';
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('id', 'temp-connection-path');
  path.setAttribute('stroke', connectionColor || '#ffff00');
  path.setAttribute('stroke-width', '3');
  path.setAttribute('stroke-dasharray', '5,5');
  path.setAttribute('fill', 'none');
  path.setAttribute('opacity', '0.8');
  
  tempConnectionLine.appendChild(path);
  viewport.appendChild(tempConnectionLine);
}

      // Update temporary connection line position
      function updateTempConnectionLine(currentX, currentY) {
        if (!tempConnectionLine || !connectionStart) return;
        
        const path = tempConnectionLine.querySelector('#temp-connection-path');
        if (!path) return;
        
        const viewport = document.getElementById('canvas-viewport');
        const rect = viewport.getBoundingClientRect();
        
        // Calculate start position from the connection point
        const startNode = connectionStart.node;
        const startX = connectionStart.isInput ? startNode.x : startNode.x + 150;
        const startY = startNode.y + 25;
        
        // Calculate current mouse position relative to viewport
        const endX = (currentX - rect.left - canvasX) / canvasScale;
        const endY = (currentY - rect.top - canvasY) / canvasScale;
        
        // Create curved path
        const dx = endX - startX;
        const curvature = Math.abs(dx) * 0.3;
        
        const pathData = `M ${startX} ${startY} C ${startX + curvature} ${startY} ${endX - curvature} ${endY} ${endX} ${endY}`;
        path.setAttribute('d', pathData);

  // Animation for the dashed line
  path.style.animation = 'dash 0.5s linear infinite';

      }

      // Remove temporary connection line
      function removeTempConnectionLine() {
        if (tempConnectionLine) {
          tempConnectionLine.remove();
          tempConnectionLine = null;
        }
      }

      // Node creation and management
      function createNode(type, x, y) {
        const nodeData = nodeTypes.find(nt => nt.name[currentLanguage] === type) || nodeTypes[0];
        const node = {
          id: generateId(),
          type: type,
          x: x || 100,
          y: y || 100,
          color: nodeData.color,
          label: type
        };
        
        nodes.push(node);
        renderNode(node);
        updateStats();
        validateFlow();
        markUnsavedChanges();
        return node;
      }

      function renderNode(node) {
        const viewport = document.getElementById('canvas-viewport');
        const nodeEl = document.createElement('div');
        nodeEl.className = 'flow-node';
        nodeEl.id = node.id;
        nodeEl.style.left = node.x + 'px';
        nodeEl.style.top = node.y + 'px';
        nodeEl.style.background = `linear-gradient(135deg, ${node.color}, ${node.color}dd)`;
        nodeEl.style.borderColor = node.color;
        nodeEl.innerHTML = `
          <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
          ${node.label}
          <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
        `;

        // Make draggable with smooth movement
        let isDragging = false;
        let offsetX, offsetY;

        nodeEl.addEventListener('mousedown', function(e) {
          if (e.target.classList.contains('connection-point')) return;
          
          // Multi-selection with Ctrl/Cmd
          if (e.ctrlKey || e.metaKey) {
            if (selectedNodes.includes(node)) {
              selectedNodes = selectedNodes.filter(n => n !== node);
              nodeEl.classList.remove('selected');
            } else {
              selectedNodes.push(node);
              nodeEl.classList.add('selected');
            }
          } else if (!selectedNodes.includes(node)) {
            // Single selection if node not already selected
            selectedNodes = [node];
            document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
            nodeEl.classList.add('selected');
          }
          
          isDragging = true;
          offsetX = (e.clientX - canvasX) / canvasScale - node.x;
          offsetY = (e.clientY - canvasY) / canvasScale - node.y;
          
          selectedNodes.forEach(n => {
            const el = document.getElementById(n.id);
            if (el) el.classList.add('dragging');
          });
        });

        document.addEventListener('mousemove', function(e) {
          if (isDragging && selectedNodes.includes(node)) {
            const newX = (e.clientX - canvasX) / canvasScale - offsetX;
            const newY = (e.clientY - canvasY) / canvasScale - offsetY;
            const deltaX = newX - node.x;
            const deltaY = newY - node.y;
            
            // Move all selected nodes
            selectedNodes.forEach(selectedNode => {
              selectedNode.x += deltaX;
              selectedNode.y += deltaY;
              const selectedEl = document.getElementById(selectedNode.id);
              if (selectedEl) {
                selectedEl.style.left = selectedNode.x + 'px';
                selectedEl.style.top = selectedNode.y + 'px';
              }
            });
            
            renderConnections();
            markUnsavedChanges();
          }
        });

        document.addEventListener('mouseup', function() {
          if (isDragging) {
            isDragging = false;
            selectedNodes.forEach(n => {
              const el = document.getElementById(n.id);
              if (el) el.classList.remove('dragging');
            });
          }
        });

        // Double click to rename
        nodeEl.addEventListener('dblclick', function(e) {
          e.stopPropagation();
          const newLabel = prompt('Enter new name for this node:', node.label);
          if (newLabel && newLabel.trim() !== '') {
            node.label = newLabel.trim();
            nodeEl.innerHTML = `
              <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
              ${node.label}
              <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
            `;
            setupConnectionHandlers(nodeEl, node);
            showToast('Node renamed successfully', 'success');
            markUnsavedChanges();
          }
        });

        // Right click context menu
        nodeEl.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          showContextMenu(e.clientX, e.clientY, node);
        });

        // Setup connection handlers
        setupConnectionHandlers(nodeEl, node);

        viewport.appendChild(nodeEl);
      }

      function setupConnectionHandlers(nodeEl, node) {
        const connectionPoints = nodeEl.querySelectorAll('.connection-point');
        connectionPoints.forEach(point => {
          // Mouse down to start dragging
          point.addEventListener('mousedown', function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const nodeId = point.getAttribute('data-node-id');
            const isInput = point.classList.contains('input-connection-point');
            
            isDraggingConnection = true;
            connectionStart = { node: nodes.find(n => n.id === nodeId), isInput };
            point.style.background = '#00ff00';
            
            // Create temporary line
            createTempConnectionLine(e.clientX, e.clientY);
            updateConnectionStatus();
          });
          
          // Click for click-to-connect mode
          point.addEventListener('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (!isDraggingConnection && !isConnecting) {
              const nodeId = point.getAttribute('data-node-id');
              const isInput = point.classList.contains('input-connection-point');
              
              isConnecting = true;
              connectionStart = { node: nodes.find(n => n.id === nodeId), isInput };
              point.style.background = '#00ff00';
              showToast('Click another connection point to connect', 'info');
              updateConnectionStatus();
            }
          });
          
          // Mouse up to complete connection
          point.addEventListener('mouseup', function(e) {
            if (isDraggingConnection && connectionStart) {
              e.stopPropagation();
              e.preventDefault();
              
              const nodeId = point.getAttribute('data-node-id');
              const isInput = point.classList.contains('input-connection-point');
              
              if (connectionStart.node.id !== nodeId && connectionStart.isInput !== isInput) {
                const fromNode = connectionStart.isInput ? nodes.find(n => n.id === nodeId) : connectionStart.node;
                const toNode = connectionStart.isInput ? connectionStart.node : nodes.find(n => n.id === nodeId);
                
                createConnection(fromNode.id, toNode.id);
                showToast('Nodes connected!', 'success');
              }
            }
          });
          
          // Visual feedback
          point.addEventListener('mouseenter', function() {
            if (isConnecting || isDraggingConnection) {
              point.style.transform = 'translateY(-50%) scale(1.5)';
              point.style.boxShadow = '0 0 15px var(--accent)';
            }
          });
          
          point.addEventListener('mouseleave', function() {
            point.style.transform = 'translateY(-50%)';
            point.style.boxShadow = '';
          });
        });
      }

      function deleteNode(nodeId) {
        // Remove from nodes array
        nodes = nodes.filter(n => n.id !== nodeId);
        selectedNodes = selectedNodes.filter(n => n.id !== nodeId);
        
        // Remove connections
        connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
        
        // Remove from DOM
        const nodeEl = document.getElementById(nodeId);
        if (nodeEl) nodeEl.remove();
        
        renderConnections();
        updateStats();
        validateFlow();
        markUnsavedChanges();
      }

      // Connection management
      function createConnection(fromId, toId) {
        // Check if connection already exists
        const exists = connections.some(c => c.from === fromId && c.to === toId);
        if (exists) {
          showToast('Connection already exists', 'warning');
          return;
        }
        
        const connection = { from: fromId, to: toId, color: connectionColor };
        connections.push(connection);
        renderConnections();
        updateStats();
        validateFlow();
        markUnsavedChanges();
      }

      function renderConnections() {
        // Remove existing connection lines
        document.querySelectorAll('.connection-line').forEach(line => line.remove());
        
        const viewport = document.getElementById('canvas-viewport');
        if (!viewport) return;
        
        connections.forEach(conn => {
          const fromNode = nodes.find(n => n.id === conn.from);
          const toNode = nodes.find(n => n.id === conn.to);
          
          if (fromNode && toNode) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('connection-line');
            
            const fromX = fromNode.x + 150;
            const fromY = fromNode.y + 25;
            const toX = toNode.x;
            const toY = toNode.y + 25;
            
            // Calculate SVG bounds with padding
            const padding = 20;
            const minX = Math.min(fromX, toX) - padding;
            const minY = Math.min(fromY, toY) - padding;
            const maxX = Math.max(fromX, toX) + padding;
            const maxY = Math.max(fromY, toY) + padding;
            
            svg.style.position = 'absolute';
            svg.style.left = minX + 'px';
            svg.style.top = minY + 'px';
            svg.style.width = (maxX - minX) + 'px';
            svg.style.height = (maxY - minY) + 'px';
            // Disable pointer events on connection lines so they do not interfere with node dragging
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1';
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Adjust coordinates relative to SVG position
            const relFromX = fromX - minX;
            const relFromY = fromY - minY;
            const relToX = toX - minX;
            const relToY = toY - minY;
            
            // Smooth curved connection
            const dx = relToX - relFromX;
            const dy = relToY - relFromY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const curvature = Math.min(distance * 0.3, 100);
            
            const pathData = `M ${relFromX} ${relFromY} C ${relFromX + curvature} ${relFromY} ${relToX - curvature} ${relToY} ${relToX} ${relToY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', conn.color || connectionColor || '#ffff00');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            
            // Add arrow marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            const markerId = 'arrow-' + conn.from + '-' + conn.to;
            marker.setAttribute('id', markerId);
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3, 0 6');
            polygon.setAttribute('fill', conn.color || connectionColor || '#ffff00');
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);

            // Ensure the connection and its components do not intercept pointer events
            // Prevent the connection path or its marker from blocking node interactions
            path.style.pointerEvents = 'none';
            polygon.style.pointerEvents = 'none';
            marker.style.pointerEvents = 'none';
            defs.style.pointerEvents = 'none';
            
            path.setAttribute('marker-end', `url(#${markerId})`);
            
            svg.appendChild(path);
            viewport.appendChild(svg);
          }
        });
      }

      // Context menu
      function showContextMenu(x, y, node) {
        const existingMenu = document.querySelector('.context-menu');
        if (existingMenu) existingMenu.remove();

        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';

        const items = [
          { text: 'Rename', action: () => {
            const newLabel = prompt('Enter new name:', node.label);
            if (newLabel) {
              node.label = newLabel;
              const nodeEl = document.getElementById(node.id);
              nodeEl.innerHTML = `
                <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
                ${node.label}
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
              `;
              setupConnectionHandlers(nodeEl, node);
              showToast('Node renamed', 'success');
              markUnsavedChanges();
            }
          }},
          { text: 'Duplicate', action: () => {
            createNode(node.type, node.x + 50, node.y + 50);
            showToast('Node duplicated', 'success');
          }},
          { text: 'Delete', action: () => {
            deleteNode(node.id);
            showToast('Node deleted', 'info');
          }}
        ];

        items.forEach(item => {
          const menuItem = document.createElement('div');
          menuItem.className = 'context-menu-item';
          menuItem.textContent = item.text;
          menuItem.onclick = () => {
            item.action();
            menu.remove();
          };
          menu.appendChild(menuItem);
        });

        document.body.appendChild(menu);

        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        });
      }

      // File operations with validation
      /**
       * Save the current flow to localStorage. When called with captureImage=true,
       * also export an image snapshot of the current flow and prompt the user to download it.
       * @param {boolean} captureImage Whether to generate and download an image of the flow
       */
      function saveFlow(captureImage = false) {
        // Pre-save validation
        validateFlow();
        
        const flowData = {
          name: document.getElementById('flow-name').value || 'Untitled',
          nodes: nodes,
          connections: connections,
          notes: flowNotes,
          created: new Date().toISOString(),
          version: '3.0',
          language: currentLanguage,
          connectionColor: connectionColor
        };
        
        localStorage.setItem('voicebot-flow-ultimate', JSON.stringify(flowData));
        markSaved();

        if (captureImage) {
          // Only generate the image when explicitly requested by the user
          try {
            captureFlowImage(flowData.name || 'flow');
            showToast('Flow saved and image downloaded!', 'success');
          } catch (err) {
            console.error(err);
            showToast('Flow saved, but failed to capture image', 'warning');
          }
        } else {
          showToast('Flow saved successfully!', 'success');
        }
      }

      /**
       * Capture the current flow layout as an image and trigger a download.
       * The image will include all nodes and connections within the flow.
       * @param {string} filenamePrefix Prefix to use for the downloaded file name.
       */
      function captureFlowImage(filenamePrefix) {
        if (!nodes || nodes.length === 0) {
          return;
        }
        // Determine bounding box of all nodes and connection endpoints
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        // Include node bounds
        nodes.forEach(n => {
          minX = Math.min(minX, n.x);
          minY = Math.min(minY, n.y);
          maxX = Math.max(maxX, n.x + 150);
          maxY = Math.max(maxY, n.y + 50);
        });
        // Include connection endpoints
        connections.forEach(c => {
          const fromNode = nodes.find(n => n.id === c.from);
          const toNode = nodes.find(n => n.id === c.to);
          if (fromNode && toNode) {
            const fx = fromNode.x + 150;
            const fy = fromNode.y + 25;
            const tx = toNode.x;
            const ty = toNode.y + 25;
            minX = Math.min(minX, fx, tx);
            minY = Math.min(minY, fy, ty);
            maxX = Math.max(maxX, fx, tx);
            maxY = Math.max(maxY, fy, ty);
          }
        });
        const padding = 40;
        const width = Math.max(1, Math.ceil(maxX - minX + padding * 2));
        const height = Math.max(1, Math.ceil(maxY - minY + padding * 2));
        // Create offscreen canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        // Fill background similar to app background
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0, 0, width, height);
        // Draw connections first (under nodes)
        connections.forEach(c => {
          const fromNode = nodes.find(n => n.id === c.from);
          const toNode = nodes.find(n => n.id === c.to);
          if (!fromNode || !toNode) return;
          // Compute relative coordinates
          const startX = (fromNode.x + 150) - minX + padding;
          const startY = (fromNode.y + 25) - minY + padding;
          const endX = toNode.x - minX + padding;
          const endY = (toNode.y + 25) - minY + padding;
          const dx = endX - startX;
          const dy = endY - startY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const curvature = Math.min(distance * 0.3, 100);
          const color = c.color || connectionColor || '#ffff00';
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.bezierCurveTo(startX + curvature, startY, endX - curvature, endY, endX, endY);
          ctx.stroke();
          // Draw arrow head
          const angle = Math.atan2(endY - startY, endX - startX);
          const arrowLength = 10;
          const arrowWidth = 6;
          const arrowX1 = endX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
          const arrowY1 = endY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
          const arrowX2 = endX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
          const arrowY2 = endY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(endX, endY);
          ctx.lineTo(arrowX1, arrowY1);
          ctx.lineTo(arrowX2, arrowY2);
          ctx.closePath();
          ctx.fill();
        });
        // Draw nodes on top
        nodes.forEach(n => {
          const x = n.x - minX + padding;
          const y = n.y - minY + padding;
          const w = 150;
          const h = 50;
          // Gradient background
          const grad = ctx.createLinearGradient(x, y, x + w, y + h);
          grad.addColorStop(0, n.color);
          // Append semi-transparent suffix 'dd' to hex color if not already
          let colorWithAlpha = n.color;
          if (/^#([0-9a-fA-F]{6})$/.test(n.color)) {
            colorWithAlpha = n.color + 'dd';
          }
          grad.addColorStop(1, colorWithAlpha);
          // Draw rounded rectangle
          const radius = 12;
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
          // Border
          ctx.strokeStyle = n.color;
          ctx.lineWidth = 2;
          ctx.stroke();
          // Node label
          ctx.fillStyle = '#e2e8f0';
          ctx.font = 'bold 14px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(n.label, x + w / 2, y + h / 2);
        });
        // Generate file name
        const timestamp = new Date();
        const yyyy = timestamp.getFullYear();
        const mm = String(timestamp.getMonth() + 1).padStart(2, '0');
        const dd = String(timestamp.getDate()).padStart(2, '0');
        const hh = String(timestamp.getHours()).padStart(2, '0');
        const min = String(timestamp.getMinutes()).padStart(2, '0');
        const ss = String(timestamp.getSeconds()).padStart(2, '0');
        const fileName = `${filenamePrefix || 'flow'}_${yyyy}${mm}${dd}_${hh}${min}${ss}.png`;
        // Trigger download
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = fileName;
        // For browsers that require the element to be in the DOM
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function loadFlow() {
        const saved = localStorage.getItem('voicebot-flow-ultimate');
        if (saved) {
          try {
            const flowData = JSON.parse(saved);
            
            // Clear current flow
            nodes = [];
            connections = [];
            selectedNodes = [];
            document.getElementById('canvas-viewport').innerHTML = '';
            
// Load data
            nodes = flowData.nodes || [];
            connections = flowData.connections || [];
            flowNotes = flowData.notes || '';
            
            if (flowData.name) {
              document.getElementById('flow-name').value = flowData.name;
              document.getElementById('flow-name-display').textContent = flowData.name;
            }
            
            if (flowData.language) {
              switchLanguage(flowData.language);
            }
            
            if (flowData.connectionColor) {
              connectionColor = flowData.connectionColor;
              updateConnectionColorPicker();
            }
            
            // Update notes textarea
            const notesTextarea = document.getElementById('flow-notes');
            if (notesTextarea && flowNotes) {
              notesTextarea.value = flowNotes;
            }
            
            // Render nodes
            nodes.forEach(node => renderNode(node));
            renderConnections();
            updateStats();
            validateFlow();
            markSaved();
            
            showToast('Flow loaded successfully!', 'success');
          } catch (e) {
            showToast('Failed to load flow', 'error');
          }
        } else {
          showToast('No saved flow found', 'warning');
        }
      }

      function exportFlow() {
        // Pre-export validation
        validateFlow();
        
        const flowData = {
          name: document.getElementById('flow-name').value || 'Untitled',
          nodes: nodes,
          connections: connections,
          notes: flowNotes,
          created: new Date().toISOString(),
          version: '3.0',
          language: currentLanguage,
          connectionColor: connectionColor,
          metadata: {
            nodeCount: nodes.length,
            connectionCount: connections.length,
            exportedBy: 'VoiceBot Flow Editor Ultimate',
            createdBy: 'Consist - Moti Kalimi'
          }
        };
        
        const blob = new Blob([JSON.stringify(flowData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (flowData.name || 'voicebot-flow') + '.json';
        a.click();
        URL.revokeObjectURL(url);
        showToast('Flow exported!', 'success');
      }

      function importFlow(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const flowData = JSON.parse(e.target.result);
            
            // Clear current flow
            nodes = [];
            connections = [];
            selectedNodes = [];
            document.getElementById('canvas-viewport').innerHTML = '';
            
            // Load data
            nodes = flowData.nodes || [];
            connections = flowData.connections || [];
            flowNotes = flowData.notes || '';
            
            if (flowData.name) {
              document.getElementById('flow-name').value = flowData.name;
              document.getElementById('flow-name-display').textContent = flowData.name;
            }
            
            if (flowData.language) {
              switchLanguage(flowData.language);
            }
            
            if (flowData.connectionColor) {
              connectionColor = flowData.connectionColor;
              updateConnectionColorPicker();
            }
            
            // Update notes textarea
            const notesTextarea = document.getElementById('flow-notes');
            if (notesTextarea && flowNotes) {
              notesTextarea.value = flowNotes;
            }
            
            // Render
            nodes.forEach(node => renderNode(node));
            renderConnections();
            updateStats();
            validateFlow();
            markSaved();
            
            showToast('Flow imported successfully!', 'success');
          } catch (e) {
            showToast('Invalid file format', 'error');
          }
        };
        reader.readAsText(file);
      }

      function clearFlow() {
        if (confirm('Are you sure you want to clear the entire flow?')) {
          nodes = [];
          connections = [];
          selectedNodes = [];
          flowNotes = '';
          document.getElementById('canvas-viewport').innerHTML = '';
          const notesTextarea = document.getElementById('flow-notes');
          if (notesTextarea) {
            notesTextarea.value = '';
          }
          updateStats();
          validateFlow();
          markUnsavedChanges();
          showToast('Flow cleared', 'info');
        }
      }

      // Search functionality
      function searchNodes(term) {
        const results = nodes.filter(node => 
          node.label.toLowerCase().includes(term.toLowerCase()) ||
          node.type.toLowerCase().includes(term.toLowerCase())
        );
        
        // Highlight matching nodes
        document.querySelectorAll('.flow-node').forEach(nodeEl => {
          nodeEl.classList.remove('search-highlight');
        });
        
        results.forEach(node => {
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.classList.add('search-highlight');
          }
        });
        
        if (results.length > 0) {
          showToast(`Found ${results.length} matching node(s)`, 'success');
        } else {
          showToast('No matching nodes found', 'warning');
        }
        
        return results;
      }

      // Layout functions
      function autoLayout() {
        if (nodes.length === 0) return;
        
        const startNodes = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת'));
        const levels = [];
        const visited = new Set();
        
        // Simple hierarchical layout starting from start nodes
        function layoutLevel(currentNodes, level = 0) {
          if (!levels[level]) levels[level] = [];
          
          currentNodes.forEach(node => {
            if (!visited.has(node.id)) {
              visited.add(node.id);
              levels[level].push(node);
              
              // Find connected nodes
              const connectedNodeIds = connections
                .filter(c => c.from === node.id)
                .map(c => c.to);
              const connectedNodes = nodes.filter(n => connectedNodeIds.includes(n.id));
              
              if (connectedNodes.length > 0) {
                layoutLevel(connectedNodes, level + 1);
              }
            }
          });
        }
        
        if (startNodes.length > 0) {
          layoutLevel(startNodes);
        }
        
        // Position nodes
        const levelWidth = 250;
        const nodeHeight = 100;
        
        levels.forEach((levelNodes, levelIndex) => {
          const x = 100 + levelIndex * levelWidth;
          levelNodes.forEach((node, nodeIndex) => {
            const y = 100 + nodeIndex * nodeHeight;
            node.x = x;
            node.y = y;
            
            const nodeEl = document.getElementById(node.id);
            if (nodeEl) {
              nodeEl.style.left = node.x + 'px';
              nodeEl.style.top = node.y + 'px';
            }
          });
        });
        
        // Layout remaining unconnected nodes
        const unvisited = nodes.filter(n => !visited.has(n.id));
        unvisited.forEach((node, index) => {
          node.x = 100 + (levels.length * levelWidth);
          node.y = 100 + index * nodeHeight;
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Auto-layout applied', 'success');
      }

      function gridLayout() {
        const cols = Math.ceil(Math.sqrt(nodes.length));
        const spacing = 200;
        
        nodes.forEach((node, index) => {
          const col = index % cols;
          const row = Math.floor(index / cols);
          
          node.x = 100 + col * spacing;
          node.y = 100 + row * spacing;
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Grid layout applied', 'success');
      }

      function circularLayout() {
        if (nodes.length <= 1) return;
        
        const centerX = 400;
        const centerY = 300;
        const radius = Math.max(150, nodes.length * 20);
        
        nodes.forEach((node, index) => {
          const angle = (index / nodes.length) * 2 * Math.PI;
          node.x = centerX + radius * Math.cos(angle);
          node.y = centerY + radius * Math.sin(angle);
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Circular layout applied', 'success');
      }

      // Language switching
      function switchLanguage(lang) {
        currentLanguage = lang;
        document.documentElement.setAttribute('dir', lang === 'he' ? 'rtl' : 'ltr');
        document.documentElement.setAttribute('lang', lang);
        updateUI();
        markUnsavedChanges();
      }

      function updateUI() {
        // Update all translatable elements
        const elements = {
          'flow-name': { placeholder: t('flowName') },
          'search-input': { placeholder: t('search') },
          'flow-notes': { placeholder: t('notesPlaceholder') }
        };
        
        Object.entries(elements).forEach(([id, attrs]) => {
          const el = document.getElementById(id);
          if (el) {
            Object.entries(attrs).forEach(([attr, value]) => {
              el[attr] = value;
            });
          }
        });
        
        // Update language buttons
        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.textContent.includes(currentLanguage === 'en' ? 'EN' : 'עב'));
        });
        
        // Update buttons and labels
        updateNodeButtons();
        
        // Update all text content
        const app = document.querySelector('.app');
        if (app) {
          createApp(); // Rebuild the entire UI with new language
        }
      }

      function updateNodeButtons() {
        const container = document.getElementById('node-buttons');
        if (!container) return;
        
        container.innerHTML = '';
        nodeTypes.forEach(nodeType => {
          const btn = document.createElement('button');
          btn.className = 'btn node-btn tooltip';
          btn.setAttribute('data-tooltip', `Add ${nodeType.name[currentLanguage]} node`);
          btn.innerHTML = `<span class="badge ${nodeType.badge}"></span> ${nodeType.name[currentLanguage]}`;
          btn.onclick = function() {
            const x = (100 + Math.random() * 200);
            const y = (100 + Math.random() * 200);
            
            createNode(nodeType.name[currentLanguage], x, y);
            showToast(`Added ${nodeType.name[currentLanguage]}`, 'success');
          };
          container.appendChild(btn);
        });
      }

      // Connection color management
      function updateConnectionColorPicker() {
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.classList.remove('active');
          if (option.classList.contains('color-yellow') && connectionColor === '#ffff00') {
            option.classList.add('active');
          } else if (option.classList.contains('color-blue') && connectionColor === '#00bfff') {
            option.classList.add('active');
          } else if (option.classList.contains('color-red') && connectionColor === '#ff4444') {
            option.classList.add('active');
          }
        });
      }

      function setConnectionColor(color) {
        connectionColor = color;
        updateConnectionColorPicker();
        
        // Update existing connections
        connections.forEach(conn => {
          conn.color = color;
        });
        renderConnections();
        markUnsavedChanges();
        
        // Update CSS variable
        document.documentElement.style.setProperty('--connection-color', color);
        
        showToast(`Connection color changed`, 'success');
      }

      // Event handlers
      function updateConnectionStatus() {
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
          if (isConnecting && connectionStart) {
            statusEl.textContent = `Connecting from ${connectionStart.node.label}...`;
          } else if (isDraggingConnection && connectionStart) {
            statusEl.textContent = `Dragging from ${connectionStart.node.label}...`;
          } else {
            statusEl.textContent = t('ready');
          }
        }
      }

      function setupEventListeners() {
        // Flow name input
        const flowNameInput = document.getElementById('flow-name');
        const flowNameDisplay = document.getElementById('flow-name-display');
        
        if (flowNameInput && flowNameDisplay) {
          flowNameInput.addEventListener('input', function() {
            flowNameDisplay.textContent = this.value || 'Untitled';
            markUnsavedChanges();
          });
        }

        // Notes textarea
        const notesTextarea = document.getElementById('flow-notes');
        if (notesTextarea) {
          notesTextarea.addEventListener('input', function() {
            flowNotes = this.value;
            markUnsavedChanges();
          });
        }

        // Search functionality
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
          searchInput.addEventListener('input', function() {
            const term = this.value.trim();
            if (term) {
              searchNodes(term);
            } else {
              // Clear highlights
              document.querySelectorAll('.flow-node').forEach(nodeEl => {
                nodeEl.classList.remove('search-highlight');
              });
            }
          });
        }

        // Canvas mouse events for panning, zooming, and selection
        const canvasContainer = document.getElementById('canvas-container');
        if (canvasContainer) {
          // Zoom with mouse wheel
          canvasContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const oldScale = canvasScale;
            if (e.deltaY < 0) {
              canvasScale = Math.min(canvasScale * 1.1, 3);
            } else {
              canvasScale = Math.max(canvasScale / 1.1, 0.1);
            }
            
            // Zoom towards mouse position
            const scaleChange = canvasScale / oldScale;
            canvasX = mouseX - (mouseX - canvasX) * scaleChange;
            canvasY = mouseY - (mouseY - canvasY) * scaleChange;
            
            updateCanvasTransform();
          });

          // Mouse events for panning and selection
          canvasContainer.addEventListener('mousedown', function(e) {
            if (e.button === 1 || (e.button === 0 && e.ctrlKey && !e.shiftKey)) {
              // Middle button or Ctrl+left for panning
              e.preventDefault();
              isPanning = true;
              panStart = { x: e.clientX - canvasX, y: e.clientY - canvasY };
              canvasContainer.classList.add('panning');
            } else if (e.button === 0 && e.shiftKey && e.target === canvasContainer) {
              // Shift+left for box selection
              e.preventDefault();
              isSelecting = true;
              const rect = canvasContainer.getBoundingClientRect();
              selectionStart = {
                x: (e.clientX - rect.left - canvasX) / canvasScale,
                y: (e.clientY - rect.top - canvasY) / canvasScale
              };
              createSelectionBox(selectionStart.x, selectionStart.y);
            } else if (e.button === 0 && e.target === canvasContainer) {
              // Clear selection when clicking on empty canvas
              selectedNodes = [];
              document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
              
              // Cancel connection mode
              if (isConnecting) {
                isConnecting = false;
                connectionStart = null;
                updateConnectionStatus();
                showToast('Connection cancelled', 'info');
              }
            }
          });

          document.addEventListener('mousemove', function(e) {
            if (isPanning) {
              canvasX = e.clientX - panStart.x;
              canvasY = e.clientY - panStart.y;
              updateCanvasTransform();
            } else if (isSelecting) {
              const rect = canvasContainer.getBoundingClientRect();
              const currentX = (e.clientX - rect.left - canvasX) / canvasScale;
              const currentY = (e.clientY - rect.top - canvasY) / canvasScale;
              updateSelectionBox(currentX, currentY);
            } else if (isDraggingConnection && connectionStart) {
              // Throttle updates of the temporary connection line to the next animation frame
              tempLineCoords = { x: e.clientX, y: e.clientY };
              if (!tempLineAnimationFrame) {
                tempLineAnimationFrame = requestAnimationFrame(() => {
                  updateTempConnectionLine(tempLineCoords.x, tempLineCoords.y);
                  tempLineAnimationFrame = null;
                });
              }
            }
          });

          document.addEventListener('mouseup', function(e) {
            if (isPanning && (e.button === 1 || e.button === 0)) {
              isPanning = false;
              canvasContainer.classList.remove('panning');
            } else if (isSelecting && e.button === 0) {
              isSelecting = false;
              removeSelectionBox();
            } else if (isDraggingConnection) {
              isDraggingConnection = false;
              removeTempConnectionLine();
              
              // Reset connection points color
              document.querySelectorAll('.connection-point').forEach(p => {
                p.style.background = '';
              });
              
              // If not on a valid connection point, cancel
              if (!e.target.classList.contains('connection-point')) {
                connectionStart = null;
                updateConnectionStatus();
              }
            } else if (isConnecting && e.target.classList.contains('connection-point')) {
              const nodeId = e.target.getAttribute('data-node-id');
              const isInput = e.target.classList.contains('input-connection-point');
              
              if (connectionStart && connectionStart.node.id !== nodeId && connectionStart.isInput !== isInput) {
                const fromNode = connectionStart.isInput ? nodes.find(n => n.id === nodeId) : connectionStart.node;
                const toNode = connectionStart.isInput ? connectionStart.node : nodes.find(n => n.id === nodeId);
                
                createConnection(fromNode.id, toNode.id);
                showToast('Nodes connected!', 'success');
              }
              
              isConnecting = false;
              connectionStart = null;
              updateConnectionStatus();
              
              // Reset colors
              document.querySelectorAll('.connection-point').forEach(p => {
                p.style.background = '';
              });
            }
          });

          // Prevent context menu on middle click
          canvasContainer.addEventListener('contextmenu', function(e) {
            if (e.target === canvasContainer) {
              e.preventDefault();
            }
          });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
          // Delete selected nodes
          if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodes.length > 0) {
            e.preventDefault();
            selectedNodes.forEach(node => deleteNode(node.id));
            selectedNodes = [];
            showToast('Deleted selected nodes', 'info');
          }
          
          // Cancel operations with Escape
          if (e.key === 'Escape') {
            isConnecting = false;
            isDraggingConnection = false;
            connectionStart = null;
            removeTempConnectionLine();
            updateConnectionStatus();
            
            // Clear selections
            selectedNodes = [];
            document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
            
            // Clear search highlights
            document.querySelectorAll('.flow-node').forEach(nodeEl => {
              nodeEl.classList.remove('search-highlight');
            });
            
            // Clear search input
            const searchInput = document.getElementById('search-input');
            if (searchInput) searchInput.value = '';
            
            // Reset connection points
            document.querySelectorAll('.connection-point').forEach(p => {
              p.style.background = '';
            });
          }
          
          // Select all with Ctrl/Cmd+A
          if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
            e.preventDefault();
            selectedNodes = [...nodes];
            document.querySelectorAll('.flow-node').forEach(n => n.classList.add('selected'));
            showToast(`Selected ${nodes.length} nodes`, 'info');
          }
          
          // Quick save with Ctrl/Cmd+S
          if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            // Quick save with image export on user command
            saveFlow(true);
          }
          
          // Copy with Ctrl/Cmd+C
          if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedNodes.length > 0) {
            e.preventDefault();
            const clipboard = {
              nodes: selectedNodes.map(node => ({...node})),
              connections: connections.filter(c => 
                selectedNodes.some(n => n.id === c.from) && 
                selectedNodes.some(n => n.id === c.to)
              )
            };
            localStorage.setItem('voicebot-clipboard', JSON.stringify(clipboard));
            showToast(`Copied ${selectedNodes.length} nodes`, 'success');
          }
          
          // Paste with Ctrl/Cmd+V
          if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
            e.preventDefault();
            const clipboardData = localStorage.getItem('voicebot-clipboard');
            if (clipboardData) {
              try {
                const clipboard = JSON.parse(clipboardData);
                const idMap = {};
                
                // Create new nodes with offset
                clipboard.nodes.forEach(node => {
                  const newId = generateId();
                  idMap[node.id] = newId;
                  const newNode = {
                    id: newId,
                    type: node.type,
                    x: node.x + 50,
                    y: node.y + 50,
                    color: node.color,
                    label: node.label
                  };
                  nodes.push(newNode);
                  renderNode(newNode);
                });
                
                // Create connections with new IDs
                clipboard.connections.forEach(conn => {
                  if (idMap[conn.from] && idMap[conn.to]) {
                    createConnection(idMap[conn.from], idMap[conn.to]);
                  }
                });
                
                showToast(`Pasted ${clipboard.nodes.length} nodes`, 'success');
              } catch (e) {
                showToast('Invalid clipboard data', 'error');
              }
            }
          }
        });

        // Remove duplicate beforeunload listener in favour of the one registered at the end of the script.
      }

      // Initialize the application
      function createApp() {
        root.innerHTML = `
          <div class="app">
            <header>
              <div class="title">
                <span id="app-title">${t('title')}</span>
                <input id="flow-name" value="New Advanced Flow" placeholder="${t('flowName')}" 
                       class="tooltip" data-tooltip="Click here to change the flow name">
              </div>
              <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                <div class="language-toggle">
                  <button class="lang-btn ${currentLanguage === 'en' ? 'active' : ''}" onclick="switchLanguage('en')">EN</button>
                  <button class="lang-btn ${currentLanguage === 'he' ? 'active' : ''}" onclick="switchLanguage('he')">עב</button>
                </div>
                <div class="autosave-indicator" id="autosave-indicator">
                  <span class="autosave-dot"></span>
                  <span class="autosave-text">${t('ready')}</span>
                </div>
                <div class="pill tooltip" data-tooltip="All advanced features enabled">✨ Ultimate Edition</div>
              </div>
            </header>
            
            <aside class="sidebar">
              <div class="stats-panel">
                <div class="stat-card tooltip" data-tooltip="Total number of nodes in your flow">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('nodes')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Total connections between nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('connections')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Number of start nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('start')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Number of end nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('end')}</div>
                </div>
              </div>
              
              <div class="group">
                <input type="text" class="search-box tooltip" id="search-input" 
                       placeholder="${t('search')}" 
                       data-tooltip="Search for nodes by name or type">
              </div>

              <h3>📝 ${t('flowNotes')}</h3>
              <div class="group">
                <textarea class="notes-textarea" id="flow-notes" 
                          placeholder="${t('notesPlaceholder')}"></textarea>
              </div>

              <div class="validation-panel">
                <h4 style="margin: 0 0 8px 0; color: var(--accent); font-size: 12px;">🔍 ${t('validation')}</h4>
                <div id="validation-results">
                  <div class="validation-item">
                    <span class="validation-icon validation-warning">⚠</span>
                    <span>No nodes in flow</span>
                  </div>
                </div>
              </div>

              <h3>🎨 ${t('connectionColors')}</h3>
              <div class="group">
                <div class="connection-color-picker">
                  <div class="color-option color-yellow active tooltip" 
                       data-tooltip="Bright Yellow" 
                       onclick="setConnectionColor('#ffff00')"></div>
                  <div class="color-option color-blue tooltip" 
                       data-tooltip="Bright Blue" 
                       onclick="setConnectionColor('#00bfff')"></div>
                  <div class="color-option color-red tooltip" 
                       data-tooltip="Bright Red" 
                       onclick="setConnectionColor('#ff4444')"></div>
                </div>
              </div>
              
              <h3>🔧 ${t('nodeTypes')}</h3>
              <div class="group" id="node-buttons">
                <!-- Node buttons will be added here -->
              </div>
              
              <h3>🎨 ${t('layoutTools')}</h3>
              <div class="group">
                <div class="layout-options">
                  <button class="layout-btn tooltip" onclick="autoLayout()" 
                          data-tooltip="Hierarchical layout based on connections">
                    ✨ Auto Layout
                  </button>
                  <button class="layout-btn tooltip" onclick="gridLayout()" 
                          data-tooltip="Arrange nodes in a grid pattern">
                    ⊞ Grid Layout
                  </button>
                  <button class="layout-btn tooltip" onclick="circularLayout()" 
                          data-tooltip="Arrange nodes in a circle">
                    ○ Circular
                  </button>
                  <button class="layout-btn tooltip" onclick="clearFlow()" 
                          data-tooltip="Remove all nodes and connections">
                    🗑️ Clear All
                  </button>
                </div>
              </div>
              
              <h3>💾 ${t('fileOps')}</h3>
              <div class="group">
                <button class="btn tooltip" onclick="saveFlow(true)" 
                        data-tooltip="Save flow to browser storage (Ctrl+S)">💾 ${t('saveFlow')}</button>
                <button class="btn tooltip" onclick="loadFlow()" 
                        data-tooltip="Load previously saved flow">📂 ${t('loadFlow')}</button>
                <button class="btn tooltip" onclick="exportFlow()" 
                        data-tooltip="Download flow as JSON file">📤 ${t('exportJson')}</button>
                <label class="btn tooltip" data-tooltip="Upload and import a JSON flow file">
                  📥 ${t('importJson')}
                  <input type="file" class="file-input" accept=".json" onchange="handleFileImport(event)">
                </label>
              </div>
              
              <div class="note">
                <strong>⌨️ ${t('controls')}:</strong><br>
                ${t('controlsText').split('\\n').join('<br>')}
              </div>
            </aside>
            
            <main>
              <div class="toolbar">
                <span class="pill">Flow: <span id="flow-name-display">New Advanced Flow</span></span>
                <span class="pill">Drag to connect nodes</span>
                <span class="pill">Status: <span id="connection-status">${t('ready')}</span></span>
                <span class="pill">Zoom: <span id="zoom-display">100%</span></span>
              </div>
              
              <div id="canvas-container">
                <div id="canvas-viewport" class="canvas-viewport">
                  <!-- Nodes and connections will be rendered here -->
                </div>
                
<div class="zoom-controls">
                  <button class="zoom-btn tooltip" onclick="zoomIn()" data-tooltip="Zoom in">+</button>
                  <div class="zoom-indicator">100%</div>
                  <button class="zoom-btn tooltip" onclick="zoomOut()" data-tooltip="Zoom out">−</button>
                  <button class="zoom-btn tooltip" onclick="resetZoom()" data-tooltip="Reset zoom and position">⌂</button>
                </div>
              </div>
            </main>
          </div>
        `;

        // Setup event listeners and initialize
        setupEventListeners();
        updateNodeButtons();
        
        // Auto-save every 3 seconds
        setInterval(() => {
          if (hasUnsavedChanges) {
            saveFlow();
          }
        }, 3000);
        
        updateStats();
        validateFlow();
        updateAutosaveIndicator();
        updateConnectionColorPicker();
      }

      // Global functions for button handlers
      window.switchLanguage = switchLanguage;
      window.autoLayout = autoLayout;
      window.gridLayout = gridLayout;
      window.circularLayout = circularLayout;
      window.clearFlow = clearFlow;
      window.saveFlow = saveFlow;
      window.loadFlow = loadFlow;
      window.exportFlow = exportFlow;
      window.zoomIn = zoomIn;
      window.zoomOut = zoomOut;
      window.resetZoom = resetZoom;
      window.setConnectionColor = setConnectionColor;
      
      window.handleFileImport = function(event) {
        const file = event.target.files[0];
        if (file) {
          importFlow(file);
          event.target.value = ''; // Reset file input
        }
      };

      // Initialize the application
      createApp();
      // Warn the user before refreshing or leaving the page if there are unsaved changes
      window.addEventListener('beforeunload', function(e) {
        // Show a confirmation dialog if there are unsaved changes when the user attempts to refresh or leave.
        if (hasUnsavedChanges) {
          e.preventDefault();
          // Modern browsers display a generic message; providing a string works in some older browsers.
          const message = 'You have unsaved changes. Are you sure you want to leave?';
          e.returnValue = message;
          return message;
        }
      });
      
      // Add a demo start node after a short delay
      setTimeout(() => {
        createNode(nodeTypes[0].name[currentLanguage], 250, 150);
        showToast('VoiceBot Flow Editor Ultimate loaded successfully!', 'success');
      }, 100);
    });
  </script>
</body>
</html>
