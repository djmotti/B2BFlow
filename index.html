<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VoiceBot Flow Editor - Ultimate</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #0b1220 0%, #1e293b 100%);
      --panel: rgba(15, 23, 42, 0.95);
      --muted: #94a3b8;
      --text: #e2e8f0;
      --accent: #22d3ee;
      --danger: #ef4444;
      --ok: #10b981;
      --warning: #f59e0b;
      --card: rgba(17, 24, 39, 0.8);
      --border: #1f2937;
      --shadow: 0 8px 32px rgba(0,0,0,.4);
      --glow: 0 0 20px rgba(34, 211, 238, 0.3);
      --connection-color: #ffff00;
    }

    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      overflow: hidden;
    }

    html[dir="rtl"] {
      direction: rtl;
    }

    .app {
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr auto;
      height: 100vh;
      position: relative;
    }

    html[dir="rtl"] .app {
      grid-template-columns: 1fr 320px;
    }

    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 200px 1fr auto;
      }
      
      html[dir="rtl"] .app {
        grid-template-columns: 1fr;
      }
      
      .sidebar {
        max-height: 200px;
        overflow-y: auto;
      }
      
      .zoom-controls {
        bottom: 10px !important;
        right: 10px !important;
        transform: scale(0.8);
      }
      
      html[dir="rtl"] .zoom-controls {
        right: auto !important;
        left: 10px !important;
      }
    }

    header {
      grid-column: 1/3;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: linear-gradient(90deg, rgba(11, 18, 32, 0.95), rgba(15, 23, 42, 0.95));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 768px) {
      header {
        padding: 8px 15px;
        font-size: 14px;
      }
    }

    .title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 18px;
    }

    @media (max-width: 768px) {
      .title {
        font-size: 16px;
        gap: 8px;
      }
    }

    .title input {
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 8px 14px;
      border-radius: 12px;
      color: #22d3ee;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.15s ease;
      backdrop-filter: blur(5px);
      position: relative;
    }

    @media (max-width: 768px) {
      .title input {
        font-size: 12px;
        padding: 6px 10px;
      }
    }

    .title input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .sidebar {
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(15px);
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
    }

    html[dir="rtl"] .sidebar {
      border-right: none;
      border-left: 1px solid var(--border);
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 3px;
    }

    .sidebar h3 {
      margin: 20px 16px 12px;
      font-size: 13px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    @media (max-width: 768px) {
      .sidebar h3 {
        margin: 10px 12px 8px;
        font-size: 12px;
      }
    }

    .group {
      padding: 0 12px 20px;
    }

    @media (max-width: 768px) {
      .group {
        padding: 0 8px 15px;
      }
    }

    .btn {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(51, 65, 85, 0.6));
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size: 13px;
      font-weight: 500;
      position: relative;
      overflow: hidden;
      display: block;
      width: 100%;
      margin-bottom: 8px;
      text-align: left;
    }

    @media (max-width: 768px) {
      .btn {
        padding: 8px 10px;
        font-size: 12px;
        margin-bottom: 6px;
      }
    }

    html[dir="rtl"] .btn {
      text-align: right;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0,0,0,.5);
      border-color: var(--accent);
    }

    .btn:active {
      transform: translateY(0);
    }

    .node-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-start;
    }

    html[dir="rtl"] .node-btn {
      justify-content: flex-end;
    }

    .badge {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      box-shadow: 0 0 8px currentColor;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .green { background: #16a34a; }
    .blue { background: #3b82f6; }
    .amber { background: #f59e0b; }
    .rose { background: #f43f5e; }
    .teal { background: #14b8a6; }
    .violet { background: #8b5cf6; }
    .slate { background: #64748b; }
    .orange { background: #ff6b35; }

    .toolbar {
      grid-column: 1/3;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 12px 20px;
      background: rgba(14, 21, 38, 0.9);
      border-top: 1px solid var(--border);
      backdrop-filter: blur(10px);
      align-items: center;
    }

    @media (max-width: 768px) {
      .toolbar {
        padding: 8px 15px;
        gap: 6px;
      }
    }

    main {
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .note {
      color: var(--muted);
      font-size: 11px;
      margin: 12px 16px;
      line-height: 1.4;
      background: rgba(30, 41, 59, 0.3);
      padding: 10px;
      border-radius: 8px;
      border-left: 3px solid var(--accent);
    }

    @media (max-width: 768px) {
      .note {
        font-size: 10px;
        margin: 8px 12px;
        padding: 8px;
      }
    }

    html[dir="rtl"] .note {
      border-left: none;
      border-right: 3px solid var(--accent);
    }

    .pill {
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 11px;
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(5px);
    }

    @media (max-width: 768px) {
      .pill {
        padding: 4px 8px;
        font-size: 10px;
      }
    }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, #111827, #1f2937);
      border: 1px solid var(--border);
      padding: 12px 18px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      display: none;
      font-size: 14px;
      z-index: 1000;
      animation: slideIn 0.2s ease;
    }

    html[dir="rtl"] .toast {
      right: auto;
      left: 20px;
    }

    @media (max-width: 768px) {
      .toast {
        bottom: 10px;
        right: 10px;
        padding: 8px 12px;
        font-size: 12px;
      }
      
      html[dir="rtl"] .toast {
        right: auto;
        left: 10px;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .stats-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .stats-panel {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
        margin-bottom: 12px;
      }
    }

    .stat-card {
      background: var(--card);
      padding: 12px 8px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid var(--border);
    }

    @media (max-width: 768px) {
      .stat-card {
        padding: 8px 6px;
      }
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: var(--accent);
    }

    @media (max-width: 768px) {
      .stat-value {
        font-size: 16px;
      }
    }

    .stat-label {
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      margin-top: 4px;
    }

    @media (max-width: 768px) {
      .stat-label {
        font-size: 9px;
      }
    }

    .search-box {
      width: 100%;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: 12px;
      color: var(--text);
      font-size: 13px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .search-box {
        padding: 8px 10px;
        font-size: 12px;
        margin-bottom: 12px;
      }
    }

    .search-box:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .notes-textarea {
      width: 100%;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid var(--border);
      padding: 10px;
      border-radius: 12px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 16px;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    .notes-textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }

    .validation-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .validation-panel {
        padding: 8px;
        margin-bottom: 12px;
      }
    }

    .validation-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      .validation-item {
        font-size: 10px;
        gap: 6px;
        padding: 4px 0;
      }
    }

    .validation-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .validation-icon {
        width: 14px;
        height: 14px;
        font-size: 9px;
      }
    }

    .validation-error { background: var(--danger); }
    .validation-warning { background: var(--warning); }
    .validation-success { background: var(--ok); }

    .context-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      box-shadow: var(--shadow);
      backdrop-filter: blur(15px);
      z-index: 1000;
      min-width: 150px;
    }

    .context-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text);
      transition: background 0.15s;
    }

    .context-menu-item:hover {
      background: rgba(34, 211, 238, 0.1);
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background-image: radial-gradient(circle, #1f2937 1px, transparent 1px);
      background-size: 20px 20px;
      cursor: grab;
      user-select: none;
    }

    #canvas-container.panning {
      cursor: grabbing;
    }

    .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      transition: transform 0.05s ease-out;
    }

    .flow-node {
      position: absolute;
      user-select: none;
      pointer-events: all;
      padding: 12px 16px;
      min-width: 150px;
      text-align: center;
      font-weight: 600;
      font-size: 13px;
      color: white;
      border: 2px solid;
      cursor: move;
      border-radius: 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
      transition: all 0.05s ease;
    }

    /* Split Decision node specific styling */
    .flow-node.split-decision {
      min-height: 80px;
      position: relative;
    }

    .flow-node.split-decision .connection-point {
      position: absolute;
    }

    .flow-node.split-decision .connection-point:nth-child(2) { 
      right: -8px; 
      top: 15%; 
    }
    .flow-node.split-decision .connection-point:nth-child(3) { 
      right: -8px; 
      top: 35%; 
    }
    .flow-node.split-decision .connection-point:nth-child(4) { 
      right: -8px; 
      top: 65%; 
    }
    .flow-node.split-decision .connection-point:nth-child(5) { 
      right: -8px; 
      top: 85%; 
    }

    @media (max-width: 768px) {
      .flow-node {
        padding: 8px 12px;
        min-width: 120px;
        font-size: 11px;
      }
    }

    .flow-node:hover {
      transform: scale(1.02);
      box-shadow: 0 12px 40px rgba(0,0,0,.6);
    }

    .flow-node.selected {
      border-width: 3px;
      box-shadow: 0 0 20px var(--accent);
    }

    .flow-node.dragging {
      z-index: 1000;
      transform: scale(1.05);
    }

    .connection-line {
      position: absolute;
      pointer-events: none;
      z-index: 1;
    }

    .connection-point {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--accent);
      border-radius: 50%;
      cursor: crosshair;
      border: 2px solid white;
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .connection-point {
        width: 10px;
        height: 10px;
        right: -6px;
      }
    }

    html[dir="rtl"] .connection-point {
      right: auto;
      left: -8px;
    }

    @media (max-width: 768px) {
      html[dir="rtl"] .connection-point {
        left: -6px;
      }
    }

    .connection-point:hover {
      transform: translateY(-50%) scale(1.3);
      box-shadow: 0 0 10px var(--accent);
    }

    .connection-point.nearby {
      transform: translateY(-50%) scale(1.5);
      background: #00ff00;
      box-shadow: 0 0 15px #00ff00;
    }

    .input-connection-point {
      right: auto;
      left: -8px;
    }

    @media (max-width: 768px) {
      .input-connection-point {
        left: -6px;
      }
    }

    html[dir="rtl"] .input-connection-point {
      left: auto;
      right: -8px;
    }

    @media (max-width: 768px) {
      html[dir="rtl"] .input-connection-point {
        right: -6px;
      }
    }

    .file-input {
      display: none;
    }

    .search-highlight {
      animation: searchPulse 0.5s ease-in-out infinite alternate;
    }
    
    @keyframes searchPulse {
      from {
        box-shadow: 0 0 10px var(--accent);
        transform: scale(1);
      }
      to {
        box-shadow: 0 0 20px var(--accent);
        transform: scale(1.02);
      }
    }

    .selection-box {
      position: absolute;
      border: 2px dashed var(--accent);
      background: rgba(34, 211, 238, 0.1);
      pointer-events: none;
      z-index: 100;
    }

    .zoom-controls {
      position: absolute;
      bottom: 4cm;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }

    html[dir="rtl"] .zoom-controls {
      right: auto;
      left: 20px;
    }

    .zoom-btn {
      width: 40px;
      height: 40px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .zoom-btn {
        width: 35px;
        height: 35px;
        font-size: 16px;
      }
    }

    .zoom-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .zoom-indicator {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      text-align: center;
      min-width: 60px;
    }

    @media (max-width: 768px) {
      .zoom-indicator {
        padding: 6px 8px;
        font-size: 10px;
        min-width: 50px;
      }
    }

    .connection-color-picker {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      justify-content: center;
    }

    .color-option {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }

    .color-option.active {
      border-color: white;
      transform: scale(1.2);
    }

    .color-yellow { background: #ffff00; }
    .color-blue { background: #00bfff; }
    .color-red { background: #ff4444; }

    .tooltip {
      position: relative;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .tooltip:hover::after {
      opacity: 1;
    }

    .language-toggle {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      display: flex;
      gap: 4px;
    }

    .lang-btn {
      padding: 6px 12px;
      background: none;
      border: none;
      color: var(--muted);
      font-size: 12px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .lang-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
    }

    .lang-btn.active {
      background: var(--accent);
      color: white;
    }

    .autosave-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    @media (max-width: 768px) {
      .autosave-indicator {
        font-size: 10px;
        gap: 6px;
      }
    }

    .autosave-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--ok);
      animation: pulse 1s infinite;
    }

    .autosave-dot.saving {
      background: var(--warning);
      animation: pulse 0.3s infinite;
    }

    .layout-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    @media (max-width: 768px) {
      .layout-options {
        gap: 6px;
      }
    }

    .layout-btn {
      padding: 8px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      text-align: center;
      font-size: 11px;
      transition: all 0.15s;
    }

    @media (max-width: 768px) {
      .layout-btn {
        padding: 6px;
        font-size: 10px;
      }
    }

    .layout-btn:hover {
      border-color: var(--accent);
      background: rgba(34, 211, 238, 0.1);
    }

    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-top: 1px solid var(--border);
      padding: 8px 20px;
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      z-index: 1000;
    }

    @media (max-width: 768px) {
      .footer {
        padding: 6px 15px;
        font-size: 10px;
      }
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -10;
      }
    }

    #temp-connection-path {
      stroke-dasharray: 5, 5;
      animation: dash 0.5s linear infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div class="toast" id="toast">Action completed</div>
  
  <div class="footer">
    Created for Consist by Moti Kalimi | יוצר לטובת קונסיסט ע"י מוטי קלימי
  </div>

  <script>
    // נסה לפתוח בכרום אם זמין
    const userAgent = navigator.userAgent;
    if (!userAgent.includes('Chrome') && !userAgent.includes('Chromium')) {
      console.log('Recommended to use Chrome browser for better performance');
    }

    document.addEventListener('DOMContentLoaded', function() {
      const root = document.getElementById('root');
      const toast = document.getElementById('toast');
      
      // Global state
      let nodes = [];
      let connections = [];
      let selectedNodes = [];
      let dragState = null;
      let nodeIdCounter = 1;
      let isConnecting = false;
      let connectionStart = null;
      let currentLanguage = 'en';
      let lastSaved = new Date();
      let hasUnsavedChanges = false;
      let connectionColor = '#ffff00';
      let flowNotes = '';
      
      // Temporary connection line for dragging
      let tempConnectionLine = null;
      let isDraggingConnection = false;
      
      // Canvas state
      let canvasScale = 1;
      let canvasX = 0;
      let canvasY = 0;
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      
      // Selection box state
      let isSelecting = false;
      let selectionStart = { x: 0, y: 0 };
      let selectionBox = null;

      // Snap distance for smart connection
      const SNAP_DISTANCE = 30;

      // Translations
      const translations = {
        en: {
title: "VoiceBot Flow Editor Ultimate",
          flowName: "Enter company name...",
          nodeTypes: "Node Types",
          layoutTools: "Layout & Tools",
          fileOps: "File Operations",
          autoLayout: "Auto Layout",
          clearAll: "Clear All",
          loadFlow: "Load Flow",
          exportJson: "Export JSON",
          importJson: "Import JSON",
          search: "Search nodes...",
          validation: "Flow Validation",
          controls: "Controls",
          controlsText: "• Drag to connect nodes\n• Double-click to rename\n• Right-click for menu\n• Shift+drag multi-select\n• Ctrl+click multi-select\n• Mouse wheel to zoom\n• Middle click to pan",
          nodes: "Nodes",
          connections: "Connections",
          start: "Start",
          end: "End",
          ready: "Ready",
          saved: "Saved",
          saving: "Saving...",
          connectionColors: "Connection Colors",
          flowNotes: "Flow Notes",
          notesPlaceholder: "Write your notes here..."
        },
        he: {
          title: "עורך זרימות VoiceBot מתקדם",
          flowName: "הזן שם החברה...",
          nodeTypes: "סוגי צמתים",
          layoutTools: "פריסה וכלים",
          fileOps: "פעולות קובץ",
          autoLayout: "פריסה אוטומטית",
          clearAll: "נקה הכל",
          loadFlow: "טען זרימה",
          exportJson: "ייצא JSON",
          importJson: "ייבא JSON",
          search: "חיפוש צמתים...",
          validation: "בדיקת זרימה",
          controls: "בקרות",
          controlsText: "• גרור כדי לחבר צמתים\n• לחיצה כפולה לשינוי שם\n• לחיצה ימנית לתפריט\n• Shift+גרירה לבחירה מרובה\n• Ctrl+לחיצה לבחירה מרובה\n• גלגלת עכבר לזום\n• לחיצה אמצעית לניווט",
          nodes: "צמתים",
          connections: "חיבורים",
          start: "התחלה",
          end: "סיום",
          ready: "מוכן",
          saved: "נשמר",
          saving: "שומר...",
          connectionColors: "צבעי חיבורים",
          flowNotes: "הערות זרימה",
          notesPlaceholder: "כתוב את הערותיך כאן..."
        }
      };

      // Node types with Hebrew translations - ADDED Split Decision node
      const nodeTypes = [
        { name: { en: 'Start Call', he: 'התחלת שיחה' }, color: '#16a34a', category: 'trigger', badge: 'green' },
        { name: { en: 'Play Audio', he: 'השמעת אודיו' }, color: '#2563eb', category: 'action', badge: 'blue' },
        { name: { en: 'Collect Input', he: 'איסוף קלט' }, color: '#0d9488', category: 'input', badge: 'teal' },
        { name: { en: 'Menu Choice', he: 'בחירת תפריט' }, color: '#7c3aed', category: 'logic', badge: 'violet' },
        { name: { en: 'Decision', he: 'החלטה' }, color: '#d97706', category: 'logic', badge: 'amber' },
        { name: { en: 'Split Decision', he: 'פיצול החלטה' }, color: '#ff6b35', category: 'logic', badge: 'orange' },
        { name: { en: 'Switch', he: 'מתג' }, color: '#6b7280', category: 'logic', badge: 'slate' },
        { name: { en: 'API Call', he: 'קריאת API' }, color: '#e11d48', category: 'action', badge: 'rose' },
        { name: { en: 'Set Variable', he: 'הגדרת משתנה' }, color: '#0d9488', category: 'data', badge: 'teal' },
        { name: { en: 'Wait', he: 'המתנה' }, color: '#6b7280', category: 'flow', badge: 'slate' },
        { name: { en: 'Transfer', he: 'העברה' }, color: '#2563eb', category: 'action', badge: 'blue' },
        { name: { en: 'End Call', he: 'סיום שיחה' }, color: '#dc2626', category: 'end', badge: 'rose' }
      ];

      // Utility functions
      function t(key) {
        return translations[currentLanguage][key] || key;
      }

      function showToast(message, type = 'info') {
        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 3000);
      }

      function generateId() {
        return 'node_' + (nodeIdCounter++);
      }

      function markUnsavedChanges() {
        hasUnsavedChanges = true;
        updateAutosaveIndicator();
      }

      function markSaved() {
        hasUnsavedChanges = false;
        lastSaved = new Date();
        updateAutosaveIndicator();
      }

      function updateAutosaveIndicator() {
        const indicator = document.getElementById('autosave-indicator');
        const dot = indicator?.querySelector('.autosave-dot');
        const text = indicator?.querySelector('.autosave-text');
        
        if (indicator && dot && text) {
          if (hasUnsavedChanges) {
            dot.className = 'autosave-dot saving';
            text.textContent = t('saving');
          } else {
            dot.className = 'autosave-dot';
            const hours = lastSaved.getHours().toString().padStart(2, '0');
            const minutes = lastSaved.getMinutes().toString().padStart(2, '0');
            const seconds = lastSaved.getSeconds().toString().padStart(2, '0');
            text.textContent = `${t('saved')} ${hours}:${minutes}:${seconds}`;
          }
        }
      }

      function updateStats() {
        const statCards = document.querySelectorAll('.stat-value');
        if (statCards.length >= 4) {
          statCards[0].textContent = nodes.length;
          statCards[1].textContent = connections.length;
          statCards[2].textContent = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת')).length;
          statCards[3].textContent = nodes.filter(n => n.type.includes('End') || n.type.includes('סיום')).length;
        }
      }

      function validateFlow() {
        const validationContainer = document.getElementById('validation-results');
        if (!validationContainer) return;

        const results = [];
        
        const startNodes = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת'));
        if (startNodes.length === 0) {
          results.push({ type: 'error', message: 'No start node found' });
        } else if (startNodes.length > 1) {
          results.push({ type: 'warning', message: 'Multiple start nodes detected' });
        }

        const endNodes = nodes.filter(n => n.type.includes('End') || n.type.includes('סיום'));
        if (endNodes.length === 0) {
          results.push({ type: 'warning', message: 'No end node found' });
        }

        const connectedNodeIds = new Set();
        connections.forEach(conn => {
          connectedNodeIds.add(conn.from);
          connectedNodeIds.add(conn.to);
        });
        
        const orphanedNodes = nodes.filter(node => 
          !connectedNodeIds.has(node.id) && !node.type.includes('Start') && !node.type.includes('התחלת')
        );
        
        if (orphanedNodes.length > 0) {
          results.push({
            type: 'warning',
            message: `${orphanedNodes.length} orphaned node(s) detected`
          });
        }

        if (results.length === 0) {
          results.push({ type: 'success', message: 'Flow validation passed' });
        }

        validationContainer.innerHTML = results.map(result => 
          `<div class="validation-item">
            <span class="validation-icon validation-${result.type}">
              ${result.type === 'error' ? '!' : result.type === 'warning' ? '⚠' : '✓'}
            </span>
            <span>${result.message}</span>
          </div>`
        ).join('');
      }

      // Canvas functions
      function updateCanvasTransform() {
        const viewport = document.getElementById('canvas-viewport');
        if (viewport) {
          viewport.style.transform = `translate(${canvasX}px, ${canvasY}px) scale(${canvasScale})`;
        }
        
        const zoomIndicator = document.querySelector('.zoom-indicator');
        if (zoomIndicator) {
          zoomIndicator.textContent = Math.round(canvasScale * 100) + '%';
        }
        
        const zoomDisplay = document.getElementById('zoom-display');
        if (zoomDisplay) {
          zoomDisplay.textContent = Math.round(canvasScale * 100) + '%';
        }
      }

      function zoomIn() {
        canvasScale = Math.min(canvasScale * 1.2, 3);
        updateCanvasTransform();
      }

      function zoomOut() {
        canvasScale = Math.max(canvasScale / 1.2, 0.1);
        updateCanvasTransform();
      }

      function resetZoom() {
        canvasScale = 1;
        canvasX = 0;
        canvasY = 0;
        updateCanvasTransform();
      }

      // ENHANCED Temporary connection line functions with smooth dashed animation
      function createTempConnectionLine(startX, startY) {
        removeTempConnectionLine();
        
        const viewport = document.getElementById('canvas-viewport');
        
        tempConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        tempConnectionLine.style.position = 'absolute';
        tempConnectionLine.style.top = '0';
        tempConnectionLine.style.left = '0';
        tempConnectionLine.style.width = '10000px';
        tempConnectionLine.style.height = '10000px';
        tempConnectionLine.style.pointerEvents = 'none';
        tempConnectionLine.style.zIndex = '1000';
        tempConnectionLine.style.overflow = 'visible';
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('id', 'temp-connection-path');
        path.setAttribute('stroke', connectionColor || '#ffff00');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-dasharray', '10,5');
        path.setAttribute('fill', 'none');
        path.setAttribute('opacity', '0.8');
        path.setAttribute('stroke-linecap', 'round');
        
        tempConnectionLine.appendChild(path);
        viewport.appendChild(tempConnectionLine);
      }

      function updateTempConnectionLine(currentX, currentY) {
        if (!tempConnectionLine || !connectionStart || !isDraggingConnection) return;

        const path = tempConnectionLine.querySelector('#temp-connection-path');
        if (!path) return;

        const viewport = document.getElementById('canvas-viewport');
        const rect = viewport.getBoundingClientRect();

        let startX, startY;
        try {
          const startNode = connectionStart.node;
          const startNodeEl = document.getElementById(startNode.id);
          let selector;
          if (connectionStart.isInput) {
            selector = '.input-connection-point';
          } else {
            selector = '.connection-point:not(.input-connection-point)';
          }
          const startPointEl = startNodeEl.querySelector(selector);
          if (startPointEl) {
            const cpRect = startPointEl.getBoundingClientRect();
            startX = (cpRect.left + cpRect.width / 2 - rect.left - canvasX) / canvasScale;
            startY = (cpRect.top + cpRect.height / 2 - rect.top - canvasY) / canvasScale;
          } else {
            const startNode = connectionStart.node;
            startX = connectionStart.isInput ? startNode.x : startNode.x + 150;
            startY = startNode.y + 25;
          }
        } catch (err) {
          const startNode = connectionStart.node;
          startX = connectionStart.isInput ? startNode.x : startNode.x + 150;
          startY = startNode.y + 25;
        }

        const endX = (currentX - rect.left - canvasX) / canvasScale;
        const endY = (currentY - rect.top - canvasY) / canvasScale;

        // Enhanced curved path with better control points
        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const curvature = Math.min(distance * 0.4, 120);

        const pathData = `M ${startX} ${startY} C ${startX + curvature} ${startY} ${endX - curvature} ${endY} ${endX} ${endY}`;
        path.setAttribute('d', pathData);

        // Enhanced animation
        path.style.animation = 'dash 0.8s linear infinite';
        
        // SMART CONNECTION: Check for nearby connection points
        checkNearbyConnectionPoints(endX, endY);
      }

      function removeTempConnectionLine() {
        if (tempConnectionLine) {
          tempConnectionLine.remove();
          tempConnectionLine = null;
        }
        // Reset all connection point states
        document.querySelectorAll('.connection-point').forEach(p => {
          p.classList.remove('nearby');
        });
      }

      // SMART CONNECTION: Find nearby connection points for auto-snap
      function checkNearbyConnectionPoints(mouseX, mouseY) {
        let nearestPoint = null;
        let minDistance = SNAP_DISTANCE;

        document.querySelectorAll('.connection-point').forEach(point => {
          if (!connectionStart) return;
          
          const nodeId = point.getAttribute('data-node-id');
          const isInput = point.classList.contains('input-connection-point');
          
          // Skip invalid connections
          if (connectionStart.node.id === nodeId || connectionStart.isInput === isInput) {
            return;
          }

          const node = nodes.find(n => n.id === nodeId);
          if (!node) return;

          let pointX, pointY;
          if (isInput) {
            pointX = node.x;
            pointY = node.y + 25;
          } else {
            pointX = node.x + 150;
            pointY = node.y + 25;
          }

          const distance = Math.sqrt(Math.pow(mouseX - pointX, 2) + Math.pow(mouseY - pointY, 2));
          
          if (distance < minDistance) {
            minDistance = distance;
            nearestPoint = point;
          }
        });

        // Reset all nearby states
        document.querySelectorAll('.connection-point').forEach(p => {
          p.classList.remove('nearby');
        });

        // Highlight nearest point if within snap distance
        if (nearestPoint) {
          nearestPoint.classList.add('nearby');
        }

        return nearestPoint;
      }

      // File operations with browser save dialog
      function exportFlowAsImage() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + 150);
          maxY = Math.max(maxY, node.y + 50);
        });
        
        const padding = 50;
        canvas.width = maxX - minX + padding * 2;
        canvas.height = maxY - minY + padding * 2;
        
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        connections.forEach(conn => {
          const fromNode = nodes.find(n => n.id === conn.from);
          const toNode = nodes.find(n => n.id === conn.to);
          
          if (fromNode && toNode) {
            ctx.strokeStyle = conn.color || connectionColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(fromNode.x - minX + padding + 150, fromNode.y - minY + padding + 25);
            ctx.lineTo(toNode.x - minX + padding, toNode.y - minY + padding + 25);
            ctx.stroke();
          }
        });
        
        nodes.forEach(node => {
          const x = node.x - minX + padding;
          const y = node.y - minY + padding;
          
          ctx.fillStyle = node.color;
          ctx.fillRect(x, y, 150, 50);
          
          ctx.strokeStyle = node.color;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, 150, 50);
          
          ctx.fillStyle = 'white';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(node.label, x + 75, y + 30);
        });
        
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = (document.getElementById('flow-name').value || 'voicebot-flow') + '.png';
          a.click();
          URL.revokeObjectURL(url);
          showToast('Flow exported as image!', 'success');
        });
      }

      function saveFlow() {
        const flowData = {
          name: document.getElementById('flow-name').value || 'שם החברה',
          nodes: nodes,
          connections: connections,
          notes: flowNotes,
          created: new Date().toISOString(),
          version: '3.0',
          language: currentLanguage,
          connectionColor: connectionColor
        };
        
        localStorage.setItem('voicebot-flow-ultimate', JSON.stringify(flowData));
        markSaved();
        showToast('Flow saved to browser storage!', 'success');
      }

      function loadFlow() {
        const saved = localStorage.getItem('voicebot-flow-ultimate');
        if (saved) {
          try {
            const flowData = JSON.parse(saved);
            
            nodes = [];
            connections = [];
            selectedNodes = [];
            document.getElementById('canvas-viewport').innerHTML = '';
            
            nodes = flowData.nodes || [];
            connections = flowData.connections || [];
            flowNotes = flowData.notes || '';
            
            if (flowData.name) {
              document.getElementById('flow-name').value = flowData.name;
              document.getElementById('flow-name-display').textContent = flowData.name;
            }
            
            if (flowData.language) {
              switchLanguage(flowData.language);
            }
            
            if (flowData.connectionColor) {
              connectionColor = flowData.connectionColor;
              updateConnectionColorPicker();
            }
            
            const notesTextarea = document.getElementById('flow-notes');
            if (notesTextarea && flowNotes) {
              notesTextarea.value = flowNotes;
            }
            
            nodes.forEach(node => renderNode(node));
            renderConnections();
            updateStats();
            validateFlow();
            markSaved();
            
            showToast('Flow loaded successfully!', 'success');
          } catch (e) {
            showToast('Failed to load flow', 'error');
          }
        } else {
          showToast('No saved flow found', 'warning');
        }
      }

      function exportFlow() {
        validateFlow();
        
        const flowData = {
          name: document.getElementById('flow-name').value || 'שם החברה',
          nodes: nodes,
          connections: connections,
          notes: flowNotes,
          created: new Date().toISOString(),
          version: '3.0',
          language: currentLanguage,
          connectionColor: connectionColor
        };
        
        const blob = new Blob([JSON.stringify(flowData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (flowData.name || 'voicebot-flow') + '.json';
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        localStorage.setItem('voicebot-flow-ultimate', JSON.stringify(flowData));
        markSaved();
        showToast('Flow exported successfully!', 'success');
      }

      function importFlow(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const flowData = JSON.parse(e.target.result);
            
            nodes = [];
            connections = [];
            selectedNodes = [];
            document.getElementById('canvas-viewport').innerHTML = '';
            
            nodes = flowData.nodes || [];
            connections = flowData.connections || [];
            flowNotes = flowData.notes || '';
            
            if (flowData.name) {
              document.getElementById('flow-name').value = flowData.name;
              document.getElementById('flow-name-display').textContent = flowData.name;
            }
            
            if (flowData.language) {
              switchLanguage(flowData.language);
            }
            
            if (flowData.connectionColor) {
              connectionColor = flowData.connectionColor;
              updateConnectionColorPicker();
            }
            
            const notesTextarea = document.getElementById('flow-notes');
            if (notesTextarea && flowNotes) {
              notesTextarea.value = flowNotes;
            }
            
            nodes.forEach(node => renderNode(node));
            renderConnections();
            updateStats();
            validateFlow();
            markSaved();
            
            showToast('Flow imported successfully!', 'success');
          } catch (e) {
            showToast('Invalid file format', 'error');
          }
        };
        reader.readAsText(file);
      }

      function clearFlow() {
        if (confirm('Are you sure you want to clear the entire flow?')) {
          nodes = [];
          connections = [];
          selectedNodes = [];
          flowNotes = '';
          document.getElementById('canvas-viewport').innerHTML = '';
          const notesTextarea = document.getElementById('flow-notes');
          if (notesTextarea) {
            notesTextarea.value = '';
          }
          updateStats();
          validateFlow();
          markUnsavedChanges();
          showToast('Flow cleared', 'info');
        }
      }

      // Create initial demo flow
      function createDemoFlow() {
        const startNode = createNode(nodeTypes[0].name[currentLanguage], 100, 150);
        const playNode = createNode(nodeTypes[1].name[currentLanguage], 300, 150);
        
        setTimeout(() => {
          createConnection(startNode.id, playNode.id);
          showToast('Demo flow created with Start Call → Play Audio', 'success');
        }, 100);
      }

      // ENHANCED Node creation with Split Decision support
      function createNode(type, x, y) {
        const nodeData = nodeTypes.find(nt => nt.name[currentLanguage] === type) || nodeTypes[0];
        const node = {
          id: generateId(),
          type: type,
          x: x || 100,
          y: y || 100,
          color: nodeData.color,
          label: type
        };
        
        nodes.push(node);
        renderNode(node);
        updateStats();
        validateFlow();
        markUnsavedChanges();
        return node;
      }

      // ENHANCED renderNode with Split Decision support
      function renderNode(node) {
        const viewport = document.getElementById('canvas-viewport');
        const nodeEl = document.createElement('div');
        nodeEl.className = 'flow-node';
        nodeEl.id = node.id;
        nodeEl.style.left = node.x + 'px';
        nodeEl.style.top = node.y + 'px';
        nodeEl.style.background = `linear-gradient(135deg, ${node.color}, ${node.color}dd)`;
        nodeEl.style.borderColor = node.color;
        
        // Check if this is a Split Decision node
        const isSplitNode = node.type.includes('Split') || node.type.includes('פיצול');
        
        if (isSplitNode) {
          nodeEl.classList.add('split-decision');
          nodeEl.innerHTML = `
            <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
            <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
            <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
            <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
            <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
            ${node.label}
          `;
        } else {
          nodeEl.innerHTML = `
            <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
            ${node.label}
            <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
          `;
        }

        let isDragging = false;
        let offsetX, offsetY;

        nodeEl.addEventListener('mousedown', function(e) {
          if (e.target.classList.contains('connection-point')) return;
          
          if (e.ctrlKey || e.metaKey) {
            if (selectedNodes.includes(node)) {
              selectedNodes = selectedNodes.filter(n => n !== node);
              nodeEl.classList.remove('selected');
            } else {
              selectedNodes.push(node);
              nodeEl.classList.add('selected');
            }
          } else if (!selectedNodes.includes(node)) {
            selectedNodes = [node];
            document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
            nodeEl.classList.add('selected');
          }
          
          isDragging = true;
          offsetX = (e.clientX - canvasX) / canvasScale - node.x;
          offsetY = (e.clientY - canvasY) / canvasScale - node.y;
          
          selectedNodes.forEach(n => {
            const el = document.getElementById(n.id);
            if (el) el.classList.add('dragging');
          });
        });

        document.addEventListener('mousemove', function(e) {
          if (isDragging && selectedNodes.includes(node)) {
            const newX = (e.clientX - canvasX) / canvasScale - offsetX;
            const newY = (e.clientY - canvasY) / canvasScale - offsetY;
            const deltaX = newX - node.x;
            const deltaY = newY - node.y;
            
            selectedNodes.forEach(selectedNode => {
              selectedNode.x += deltaX;
              selectedNode.y += deltaY;
              const selectedEl = document.getElementById(selectedNode.id);
              if (selectedEl) {
                selectedEl.style.left = selectedNode.x + 'px';
                selectedEl.style.top = selectedNode.y + 'px';
              }
            });
            
            renderConnections();
            markUnsavedChanges();
          }
        });

        document.addEventListener('mouseup', function() {
          if (isDragging) {
            isDragging = false;
            selectedNodes.forEach(n => {
              const el = document.getElementById(n.id);
              if (el) el.classList.remove('dragging');
            });
          }
        });

        nodeEl.addEventListener('dblclick', function(e) {
          e.stopPropagation();
          const newLabel = prompt('Enter new name for this node:', node.label);
          if (newLabel && newLabel.trim() !== '') {
            node.label = newLabel.trim();
            if (isSplitNode) {
              nodeEl.innerHTML = `
                <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
                ${node.label}
              `;
            } else {
              nodeEl.innerHTML = `
                <div class="input-connection-point connection-point" data-node-id="${node.id}" data-type="input"></div>
                ${node.label}
                <div class="connection-point" data-node-id="${node.id}" data-type="output"></div>
              `;
            }
            setupConnectionHandlers(nodeEl, node);
            showToast('Node renamed successfully', 'success');
            markUnsavedChanges();
          }
        });

        setupConnectionHandlers(nodeEl, node);
        viewport.appendChild(nodeEl);
      }

// ENHANCED setupConnectionHandlers with smart drag connections and snap feature
      function setupConnectionHandlers(nodeEl, node) {
        const connectionPoints = nodeEl.querySelectorAll('.connection-point');
        connectionPoints.forEach(point => {
          // Enhanced mousedown with drag connection support
          point.addEventListener('mousedown', function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const nodeId = point.getAttribute('data-node-id');
            const isInput = point.classList.contains('input-connection-point');
            
            // Start drag connection mode
            isDraggingConnection = true;
            connectionStart = { node: nodes.find(n => n.id === nodeId), isInput };
            point.style.background = '#00ff00';
            
            // Create animated temporary line
            createTempConnectionLine(e.clientX, e.clientY);
            updateConnectionStatus();
          });
          
          // Click for point-to-point connection (existing functionality)
          point.addEventListener('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (!isDraggingConnection && !isConnecting) {
              const nodeId = point.getAttribute('data-node-id');
              const isInput = point.classList.contains('input-connection-point');
              
              isConnecting = true;
              connectionStart = { node: nodes.find(n => n.id === nodeId), isInput };
              point.style.background = '#00ff00';
              showToast('Click another connection point to connect', 'info');
              updateConnectionStatus();
            } else if (isConnecting && connectionStart) {
              const nodeId = point.getAttribute('data-node-id');
              const isInput = point.classList.contains('input-connection-point');
              
              if (connectionStart.node.id !== nodeId && connectionStart.isInput !== isInput) {
                const fromNode = connectionStart.isInput ? nodes.find(n => n.id === nodeId) : connectionStart.node;
                const toNode = connectionStart.isInput ? connectionStart.node : nodes.find(n => n.id === nodeId);
                
                createConnection(fromNode.id, toNode.id);
                showToast('Nodes connected!', 'success');
              }
              
              isConnecting = false;
              connectionStart = null;
              updateConnectionStatus();
              document.querySelectorAll('.connection-point').forEach(p => {
                p.style.background = '';
              });
            }
          });
          
          // Enhanced mouseup with smart snap connection
          point.addEventListener('mouseup', function(e) {
            if (isDraggingConnection && connectionStart) {
              e.stopPropagation();
              e.preventDefault();
              
              const nodeId = point.getAttribute('data-node-id');
              const isInput = point.classList.contains('input-connection-point');
              
              if (connectionStart.node.id !== nodeId && connectionStart.isInput !== isInput) {
                const fromNode = connectionStart.isInput ? nodes.find(n => n.id === nodeId) : connectionStart.node;
                const toNode = connectionStart.isInput ? connectionStart.node : nodes.find(n => n.id === nodeId);
                
                createConnection(fromNode.id, toNode.id);
                showToast('Nodes connected!', 'success');
              }
              
              // Clean up drag state
              isDraggingConnection = false;
              connectionStart = null;
              removeTempConnectionLine();
              updateConnectionStatus();
              
              document.querySelectorAll('.connection-point').forEach(p => {
                p.style.background = '';
              });
            }
          });
          
          // Visual feedback for connection points
          point.addEventListener('mouseenter', function() {
            if (isConnecting || isDraggingConnection) {
              point.style.transform = 'translateY(-50%) scale(1.5)';
              point.style.boxShadow = '0 0 15px var(--accent)';
            }
          });
          
          point.addEventListener('mouseleave', function() {
            if (!isDraggingConnection || connectionStart?.node.id !== point.getAttribute('data-node-id')) {
              point.style.transform = 'translateY(-50%)';
              point.style.boxShadow = '';
            }
          });
        });
      }

      function createConnection(fromId, toId) {
        const exists = connections.some(c => c.from === fromId && c.to === toId);
        if (exists) {
          showToast('Connection already exists', 'warning');
          return;
        }
        
        const connection = { from: fromId, to: toId, color: connectionColor };
        connections.push(connection);
        renderConnections();
        updateStats();
        validateFlow();
        markUnsavedChanges();
      }

      function renderConnections() {
        document.querySelectorAll('.connection-line').forEach(line => line.remove());
        
        const viewport = document.getElementById('canvas-viewport');
        if (!viewport) return;
        
        connections.forEach(conn => {
          const fromNode = nodes.find(n => n.id === conn.from);
          const toNode = nodes.find(n => n.id === conn.to);
          
          if (fromNode && toNode) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('connection-line');
            
            const fromX = fromNode.x + 150;
            const fromY = fromNode.y + 25;
            const toX = toNode.x;
            const toY = toNode.y + 25;
            
            const padding = 20;
            const minX = Math.min(fromX, toX) - padding;
            const minY = Math.min(fromY, toY) - padding;
            const maxX = Math.max(fromX, toX) + padding;
            const maxY = Math.max(fromY, toY) + padding;
            
            svg.style.position = 'absolute';
            svg.style.left = minX + 'px';
            svg.style.top = minY + 'px';
            svg.style.width = (maxX - minX) + 'px';
            svg.style.height = (maxY - minY) + 'px';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1';
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const relFromX = fromX - minX;
            const relFromY = fromY - minY;
            const relToX = toX - minX;
            const relToY = toY - minY;
            
            const dx = relToX - relFromX;
            const dy = relToY - relFromY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const curvature = Math.min(distance * 0.3, 100);
            
            const pathData = `M ${relFromX} ${relFromY} C ${relFromX + curvature} ${relFromY} ${relToX - curvature} ${relToY} ${relToX} ${relToY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', conn.color || connectionColor || '#ffff00');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            const markerId = 'arrow-' + conn.from + '-' + conn.to;
            marker.setAttribute('id', markerId);
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3, 0 6');
            polygon.setAttribute('fill', conn.color || connectionColor || '#ffff00');
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            path.setAttribute('marker-end', `url(#${markerId})`);
            
            svg.appendChild(path);
            viewport.appendChild(svg);
          }
        });
      }

      function switchLanguage(lang) {
        currentLanguage = lang;
        document.documentElement.setAttribute('dir', lang === 'he' ? 'rtl' : 'ltr');
        document.documentElement.setAttribute('lang', lang);
        updateUI();
        markUnsavedChanges();
      }

      function updateUI() {
        const elements = {
          'flow-name': { placeholder: t('flowName') },
          'search-input': { placeholder: t('search') },
          'flow-notes': { placeholder: t('notesPlaceholder') }
        };
        
        Object.entries(elements).forEach(([id, attrs]) => {
          const el = document.getElementById(id);
          if (el) {
            Object.entries(attrs).forEach(([attr, value]) => {
              el[attr] = value;
            });
          }
        });
        
        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.textContent.includes(currentLanguage === 'en' ? 'EN' : 'עב'));
        });
        
        updateNodeButtons();
        
        const app = document.querySelector('.app');
        if (app) {
          createApp();
        }
      }

      function updateNodeButtons() {
        const container = document.getElementById('node-buttons');
        if (!container) return;
        container.innerHTML = '';
        nodeTypes.forEach(nodeType => {
          const btn = document.createElement('button');
          btn.className = 'btn node-btn tooltip';
          btn.setAttribute('data-tooltip', `Add ${nodeType.name[currentLanguage]} node`);
          btn.setAttribute('draggable', 'true');
          btn.innerHTML = `<span class="badge ${nodeType.badge}"></span> ${nodeType.name[currentLanguage]}`;
          btn.onclick = function() {
            const x = (100 + Math.random() * 200);
            const y = (100 + Math.random() * 200);
            createNode(nodeType.name[currentLanguage], x, y);
            showToast(`Added ${nodeType.name[currentLanguage]}`, 'success');
          };
          
          btn.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', nodeType.name[currentLanguage]);
            e.dataTransfer.effectAllowed = 'copy';
          });
          container.appendChild(btn);
        });
      }

      function updateConnectionColorPicker() {
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.classList.remove('active');
          if (option.classList.contains('color-yellow') && connectionColor === '#ffff00') {
            option.classList.add('active');
          } else if (option.classList.contains('color-blue') && connectionColor === '#00bfff') {
            option.classList.add('active');
          } else if (option.classList.contains('color-red') && connectionColor === '#ff4444') {
            option.classList.add('active');
          }
        });
      }

      function setConnectionColor(color) {
        connectionColor = color;
        updateConnectionColorPicker();
        connections.forEach(conn => {
          conn.color = color;
        });
        renderConnections();
        markUnsavedChanges();
        document.documentElement.style.setProperty('--connection-color', color);
        showToast('Connection color changed', 'success');
      }

      function autoLayout() {
        if (nodes.length === 0) return;
        
        const startNodes = nodes.filter(n => n.type.includes('Start') || n.type.includes('התחלת'));
        const levels = [];
        const visited = new Set();
        
        function layoutLevel(currentNodes, level = 0) {
          if (!levels[level]) levels[level] = [];
          
          currentNodes.forEach(node => {
            if (!visited.has(node.id)) {
              visited.add(node.id);
              levels[level].push(node);
              
              const connectedNodeIds = connections
                .filter(c => c.from === node.id)
                .map(c => c.to);
              const connectedNodes = nodes.filter(n => connectedNodeIds.includes(n.id));
              
              if (connectedNodes.length > 0) {
                layoutLevel(connectedNodes, level + 1);
              }
            }
          });
        }
        
        if (startNodes.length > 0) {
          layoutLevel(startNodes);
        }
        
        const levelWidth = 250;
        const nodeHeight = 100;
        
        levels.forEach((levelNodes, levelIndex) => {
          const x = 100 + levelIndex * levelWidth;
          levelNodes.forEach((node, nodeIndex) => {
            const y = 100 + nodeIndex * nodeHeight;
            node.x = x;
            node.y = y;
            
            const nodeEl = document.getElementById(node.id);
            if (nodeEl) {
              nodeEl.style.left = node.x + 'px';
              nodeEl.style.top = node.y + 'px';
            }
          });
        });
        
        const unvisited = nodes.filter(n => !visited.has(n.id));
        unvisited.forEach((node, index) => {
          node.x = 100 + (levels.length * levelWidth);
          node.y = 100 + index * nodeHeight;
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Auto-layout applied', 'success');
      }

      function gridLayout() {
        const cols = Math.ceil(Math.sqrt(nodes.length));
        const spacing = 200;
        
        nodes.forEach((node, index) => {
          const col = index % cols;
          const row = Math.floor(index / cols);
          
          node.x = 100 + col * spacing;
          node.y = 100 + row * spacing;
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Grid layout applied', 'success');
      }

      function circularLayout() {
        if (nodes.length <= 1) return;
        
        const centerX = 400;
        const centerY = 300;
        const radius = Math.max(150, nodes.length * 20);
        
        nodes.forEach((node, index) => {
          const angle = (index / nodes.length) * 2 * Math.PI;
          node.x = centerX + radius * Math.cos(angle);
          node.y = centerY + radius * Math.sin(angle);
          
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
          }
        });
        
        renderConnections();
        markUnsavedChanges();
        showToast('Circular layout applied', 'success');
      }

      // Enhanced updateConnectionStatus function
      function updateConnectionStatus() {
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
          if (isConnecting && connectionStart) {
            statusEl.textContent = `Connecting from ${connectionStart.node.label}...`;
          } else if (isDraggingConnection && connectionStart) {
            statusEl.textContent = `Dragging from ${connectionStart.node.label}...`;
          } else {
            statusEl.textContent = t('ready');
          }
        }
      }

      function setupEventListeners() {
        const flowNameInput = document.getElementById('flow-name');
        const flowNameDisplay = document.getElementById('flow-name-display');
        
        if (flowNameInput && flowNameDisplay) {
          flowNameInput.addEventListener('input', function() {
            flowNameDisplay.textContent = this.value || 'שם החברה';
            markUnsavedChanges();
          });
        }

        const notesTextarea = document.getElementById('flow-notes');
        if (notesTextarea) {
          notesTextarea.addEventListener('input', function() {
            flowNotes = this.value;
            markUnsavedChanges();
          });
        }

        const canvasContainer = document.getElementById('canvas-container');
        if (canvasContainer) {
          canvasContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const oldScale = canvasScale;
            if (e.deltaY < 0) {
              canvasScale = Math.min(canvasScale * 1.1, 3);
            } else {
              canvasScale = Math.max(canvasScale / 1.1, 0.1);
            }
            
            const scaleChange = canvasScale / oldScale;
            canvasX = mouseX - (mouseX - canvasX) * scaleChange;
            canvasY = mouseY - (mouseY - canvasY) * scaleChange;
            
            updateCanvasTransform();
          });

          canvasContainer.addEventListener('mousedown', function(e) {
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
              e.preventDefault();
              isPanning = true;
              panStart = { x: e.clientX - canvasX, y: e.clientY - canvasY };
              canvasContainer.classList.add('panning');
            } else if (e.button === 0 && e.target === canvasContainer) {
              selectedNodes = [];
              document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
              
              if (isConnecting) {
                isConnecting = false;
                connectionStart = null;
                updateConnectionStatus();
                showToast('Connection cancelled', 'info');
              }
            }
          });

          // Enhanced global mouse move handler for drag connections
          document.addEventListener('mousemove', function(e) {
            if (isPanning) {
              canvasX = e.clientX - panStart.x;
              canvasY = e.clientY - panStart.y;
              updateCanvasTransform();
            } else if (isDraggingConnection && connectionStart) {
              updateTempConnectionLine(e.clientX, e.clientY);
            }
          });

          // Enhanced global mouse up handler with smart snap
          document.addEventListener('mouseup', function(e) {
            if (isPanning && (e.button === 1 || e.button === 0)) {
              isPanning = false;
              canvasContainer.classList.remove('panning');
            } else if (isDraggingConnection) {
              // Check for nearby connection points and auto-connect
              const viewport = document.getElementById('canvas-viewport');
              const rect = viewport.getBoundingClientRect();
              const mouseX = (e.clientX - rect.left - canvasX) / canvasScale;
              const mouseY = (e.clientY - rect.top - canvasY) / canvasScale;
              
              const nearestPoint = checkNearbyConnectionPoints(mouseX, mouseY);
              
              if (nearestPoint && connectionStart) {
                const nodeId = nearestPoint.getAttribute('data-node-id');
                const isInput = nearestPoint.classList.contains('input-connection-point');
                
                if (connectionStart.node.id !== nodeId && connectionStart.isInput !== isInput) {
                  const fromNode = connectionStart.isInput ? nodes.find(n => n.id === nodeId) : connectionStart.node;
                  const toNode = connectionStart.isInput ? connectionStart.node : nodes.find(n => n.id === nodeId);
                  
                  createConnection(fromNode.id, toNode.id);
                  showToast('Smart connection created!', 'success');
                }
              }
              
              // Clean up drag state
              isDraggingConnection = false;
              connectionStart = null;
              removeTempConnectionLine();
              updateConnectionStatus();
              
              document.querySelectorAll('.connection-point').forEach(p => {
                p.style.background = '';
              });
            }
          });

          canvasContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = 'copy';
            }
          });

          canvasContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            const typeName = e.dataTransfer ? e.dataTransfer.getData('text/plain') : '';
            if (typeName) {
              const rect = canvasContainer.getBoundingClientRect();
              const x = (e.clientX - rect.left - canvasX) / canvasScale;
              const y = (e.clientY - rect.top - canvasY) / canvasScale;
              createNode(typeName, x, y);
              showToast(`Added ${typeName}`, 'success');
            }
          });
        }

        document.addEventListener('keydown', function(e) {
          if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodes.length > 0) {
            e.preventDefault();
            selectedNodes.forEach(node => {
              nodes = nodes.filter(n => n.id !== node.id);
              connections = connections.filter(c => c.from !== node.id && c.to !== node.id);
              const nodeEl = document.getElementById(node.id);
              if (nodeEl) nodeEl.remove();
            });
            selectedNodes = [];
            renderConnections();
            updateStats();
            validateFlow();
            markUnsavedChanges();
            showToast('Deleted selected nodes', 'info');
          }
          
          if (e.key === 'Escape') {
            isConnecting = false;
            isDraggingConnection = false;
            connectionStart = null;
            removeTempConnectionLine();
            updateConnectionStatus();
            selectedNodes = [];
            document.querySelectorAll('.flow-node').forEach(n => n.classList.remove('selected'));
            document.querySelectorAll('.connection-point').forEach(p => {
              p.style.background = '';
            });
          }
          
          if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            saveFlow();
          }
        });
      }

      function createApp() {
        root.innerHTML = `
          <div class="app">
            <header>
              <div class="title">
                <span id="app-title">${t('title')}</span>
                <input id="flow-name" value="שם החברה" placeholder="${t('flowName')}" 
                       class="tooltip" data-tooltip="Click here to change the company name">
              </div>
              <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                <div class="language-toggle">
                  <button class="lang-btn ${currentLanguage === 'en' ? 'active' : ''}" onclick="switchLanguage('en')">EN</button>
                  <button class="lang-btn ${currentLanguage === 'he' ? 'active' : ''}" onclick="switchLanguage('he')">עב</button>
                </div>
                <div class="autosave-indicator" id="autosave-indicator">
                  <span class="autosave-dot"></span>
                  <span class="autosave-text">${t('ready')}</span>
                </div>
                <div class="pill tooltip" data-tooltip="All advanced features enabled">✨ Ultimate Edition</div>
              </div>
            </header>
            
            <aside class="sidebar">
              <div class="stats-panel">
                <div class="stat-card tooltip" data-tooltip="Total number of nodes in your flow">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('nodes')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Total connections between nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('connections')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Number of start nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('start')}</div>
                </div>
                <div class="stat-card tooltip" data-tooltip="Number of end nodes">
                  <div class="stat-value">0</div>
                  <div class="stat-label">${t('end')}</div>
                </div>
              </div>
              
              <div class="group">
                <input type="text" class="search-box tooltip" id="search-input" 
                       placeholder="${t('search')}" 
                       data-tooltip="Search for nodes by name or type">
              </div>

              <div class="validation-panel">
                <h4 style="margin: 0 0 8px 0; color: var(--accent); font-size: 12px;">🔍 ${t('validation')}</h4>
                <div id="validation-results">
                  <div class="validation-item">
                    <span class="validation-icon validation-warning">⚠</span>
                    <span>No nodes in flow</span>
                  </div>
                </div>
              </div>

              <h3>🔧 ${t('nodeTypes')}</h3>
              <div class="group" id="node-buttons">
                <!-- Node buttons will be added here -->
              </div>

              <h3>📝 ${t('flowNotes')}</h3>
              <div class="group">
                <textarea class="notes-textarea" id="flow-notes" 
                          placeholder="${t('notesPlaceholder')}"></textarea>
              </div>

              <h3>🎨 ${t('connectionColors')}</h3>
              <div class="group">
                <div class="connection-color-picker">
                  <div class="color-option color-yellow active tooltip" 
                       data-tooltip="Bright Yellow" 
                       onclick="setConnectionColor('#ffff00')"></div>
                  <div class="color-option color-blue tooltip" 
                       data-tooltip="Bright Blue" 
                       onclick="setConnectionColor('#00bfff')"></div>
                  <div class="color-option color-red tooltip" 
                       data-tooltip="Bright Red" 
                       onclick="setConnectionColor('#ff4444')"></div>
                </div>
              </div>
              
              <h3>🎨 ${t('layoutTools')}</h3>
              <div class="group">
                <div class="layout-options">
                  <button class="layout-btn tooltip" onclick="autoLayout()" 
                          data-tooltip="Hierarchical layout based on connections">
                    ✨ Auto Layout
                  </button>
                  <button class="layout-btn tooltip" onclick="gridLayout()" 
                          data-tooltip="Arrange nodes in a grid pattern">
                    ⊞ Grid Layout
                  </button>
                  <button class="layout-btn tooltip" onclick="circularLayout()" 
                          data-tooltip="Arrange nodes in a circle">
                    ○ Circular
                  </button>
                  <button class="layout-btn tooltip" onclick="clearFlow()" 
                          data-tooltip="Remove all nodes and connections">
                    🗑️ Clear All
                  </button>
                </div>
              </div>
              
              <h3>💾 ${t('fileOps')}</h3>
              <div class="group">
                <button class="btn tooltip" onclick="loadFlow()" 
                        data-tooltip="Load previously saved flow">📂 ${t('loadFlow')}</button>
                <button class="btn tooltip" onclick="exportFlow()" 
                        data-tooltip="Download flow as JSON file">📤 ${t('exportJson')}</button>
                <button class="btn tooltip" onclick="exportFlowAsImage()" 
                        data-tooltip="Export flow as PNG image">🖼️ Export PNG</button>
                <label class="btn tooltip" data-tooltip="Upload and import a JSON flow file">
                  📥 ${t('importJson')}
                  <input type="file" class="file-input" accept=".json" onchange="handleFileImport(event)">
                </label>
              </div>
              
              <div class="note">
                <strong>⌨️ ${t('controls')}:</strong><br>
                ${t('controlsText').split('\\n').join('<br>')}
              </div>
            </aside>
            
            <main>
              <div class="toolbar">
                <span class="pill">Flow: <span id="flow-name-display">שם החברה</span></span>
                <span class="pill">Drag to connect nodes</span>
                <span class="pill">Status: <span id="connection-status">${t('ready')}</span></span>
                <span class="pill">Zoom: <span id="zoom-display">100%</span></span>
              </div>
              
              <div id="canvas-container">
                <div id="canvas-viewport" class="canvas-viewport">
                  <!-- Nodes and connections will be rendered here -->
                </div>
                
                <div class="zoom-controls">
                  <button class="zoom-btn tooltip" onclick="zoomIn()" data-tooltip="Zoom in">+</button>
                  <div class="zoom-indicator">100%</div>
                  <button class="zoom-btn tooltip" onclick="zoomOut()" data-tooltip="Zoom out">−</button>
                  <button class="zoom-btn tooltip" onclick="resetZoom()" data-tooltip="Reset zoom and position">⌂</button>
                </div>
              </div>
            </main>
          </div>
        `;

        setupEventListeners();
        updateNodeButtons();
        
        setInterval(() => {
          if (hasUnsavedChanges) {
            saveFlow();
          }
        }, 3000);
        
        updateStats();
        validateFlow();
        updateAutosaveIndicator();
        updateConnectionColorPicker();
      }

// Global functions for button handlers
      window.switchLanguage = switchLanguage;
      window.autoLayout = autoLayout;
      window.gridLayout = gridLayout;
      window.circularLayout = circularLayout;
      window.clearFlow = clearFlow;
      window.loadFlow = loadFlow;
      window.exportFlow = exportFlow;
      window.exportFlowAsImage = exportFlowAsImage;
      window.zoomIn = zoomIn;
      window.zoomOut = zoomOut;
      window.resetZoom = resetZoom;
      window.setConnectionColor = setConnectionColor;
      
      window.handleFileImport = function(event) {
        const file = event.target.files[0];
        if (file) {
          importFlow(file);
          event.target.value = '';
        }
      };

      // Initialize the application
      createApp();
      
      // Create demo flow with Start Call and Play Audio connected
      setTimeout(() => {
        createDemoFlow();
      }, 100);
    });
  </script>
</body>
</html>
